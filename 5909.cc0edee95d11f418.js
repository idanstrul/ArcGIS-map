"use strict";var Xt=Object.defineProperty,Bt=Object.getOwnPropertySymbols,Yt=Object.prototype.hasOwnProperty,Nt=Object.prototype.propertyIsEnumerable,Ht=(At,Pt,z)=>Pt in At?Xt(At,Pt,{enumerable:!0,configurable:!0,writable:!0,value:z}):At[Pt]=z,Ut=(At,Pt)=>{for(var z in Pt||(Pt={}))Yt.call(Pt,z)&&Ht(At,z,Pt[z]);if(Bt)for(var z of Bt(Pt))Nt.call(Pt,z)&&Ht(At,z,Pt[z]);return At};(self.webpackChunkKapow_Maps_Exam=self.webpackChunkKapow_Maps_Exam||[]).push([[5909],{986:(At,Pt,z)=>{z.d(Pt,{E:()=>J});const W=new(z(6879).Z);function J(lt){if(!W.hasBidiChar(lt))return[lt,!1];let xt;return xt="rtl"===W.checkContextual(lt)?"IDNNN":"ICNNN",[W.bidiTransform(lt,xt,"VLYSN"),!0]}},36161:(At,Pt,z)=>{z.d(Pt,{I:()=>W,v:()=>J});var ct=z(21286);function W(U,I,V=0){const j=(0,ct.uZ)(U,0,M);for(let nt=0;nt<4;nt++)I[V+nt]=Math.floor(256*bt(j*lt[nt]))}function J(U,I=0){let V=0;for(let j=0;j<4;j++)V+=U[I+j]*xt[j];return V}const lt=[1,256,65536,16777216],xt=[1/256,1/65536,1/16777216,1/4294967296],M=J(new Uint8ClampedArray([255,255,255,255]));function bt(U){return U-Math.floor(U)}},72283:(At,Pt,z)=>{z.d(Pt,{GP:()=>lt,QK:()=>dt,XV:()=>Et,hh:()=>pt,ov:()=>$,qh:()=>Tt,v1:()=>It,wp:()=>Z,zY:()=>zt,zv:()=>Lt});var ct=z(58817),W=z(91179),J=z(97373);function lt(x){const N=(0,ct.d9)(x);return function nt(x){x&&((0,W.oU)(x)?j(x.rings):(0,W.l9)(x)?j(x.paths):(0,W.aW)(x)&&V(x.points),xt(x))}(N),N}function xt(x){if(!x)return null;(0,W.wp)(x)?x.y=-x.y:(0,W.oU)(x)?bt(x.rings):(0,W.l9)(x)?bt(x.paths):(0,W.aW)(x)&&M(x.points)}function M(x){if(x){const N=x.length;for(let Q=0;Q<N;Q++)x[Q][1]=-x[Q][1]}}function bt(x){if(x)for(const N of x)M(N)}function U(x){if(x)for(let N=x.length-1;N>0;--N)x[N][0]-=x[N-1][0],x[N][1]-=x[N-1][1]}function I(x){if(x)for(const N of x)U(N)}function V(x){if(x){const N=x.length;for(let Q=1;Q<N;++Q)x[Q][0]+=x[Q-1][0],x[Q][1]+=x[Q-1][1]}}function j(x){if(x)for(const N of x)V(N)}function Z(x){x&&(xt(x),(0,W.oU)(x)?I(x.rings):(0,W.l9)(x)?I(x.paths):(0,W.aW)(x)&&U(x.points))}function $(x){if(x)for(const N of x)pt(N)}function pt(x){x&&x.reverse()}function Et(x,N,Q){return[x[0]+(N[0]-x[0])*Q,x[1]+(N[1]-x[1])*Q]}function dt(x){return!(!x||0===x.length)&&x[0][0]===x[x.length-1][0]&&x[0][1]===x[x.length-1][1]}function Lt(x){return x[4]}function Tt(x,N){x[4]=N}class It{constructor(N,Q,k,O){this.acceptPolygon=Q,this.acceptPolyline=k,this.geomUnitsPerPoint=O,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,N&&((0,W.oU)(N)?Q&&(this.multiPath=N.rings,this.isClosed=!0):(0,W.l9)(N)?k&&(this.multiPath=N.paths,this.isClosed=!1):(0,W.YX)(N)&&Q&&(this.multiPath=Ct(N).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new J.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const N=this.processPath(this.multiPath[this.pathIndex]);if(N)return N}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class zt{constructor(N,Q,k,O){this.inputGeometries=N,this.acceptPolygon=Q,this.acceptPolyline=k,this.geomUnitsPerPoint=O,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let N=this.inputGeometries.next();for(;N;){if((0,W.oU)(N)?this.acceptPolygon&&(this.multiPath=N.rings,this.isClosed=!0):(0,W.l9)(N)?this.acceptPolyline&&(this.multiPath=N.paths,this.isClosed=!1):(0,W.YX)(N)&&this.acceptPolygon&&(this.multiPath=Ct(N).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}N=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const N=this.processPath(this.multiPath[this.pathIndex]);if(N)return N}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function Ct(x){return{rings:[[[x.xmin,x.ymin],[x.xmin,x.ymax],[x.xmax,x.ymax],[x.xmax,x.ymin],[x.xmin,x.ymin]]]}}},29214:(At,Pt,z)=>{z.d(Pt,{M:()=>W}),z(58817);class W{constructor(xt){this._geometry=xt}next(){const xt=this._geometry;return this._geometry=null,xt}}},11004:(At,Pt,z)=>{z.d(Pt,{h:()=>Ft,W:()=>Ot});var ct=z(58817),W=z(91179),J=z(72283);let lt=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new xt(e,i,o)}}return _.instance=null,_})();class xt{constructor(s,e,i){this._inputGeometries=s,this._angleTolerance=void 0!==e.angleTolerance?e.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let s=this._inputGeometries.next();for(;s;){if((0,W.oU)(s)){this._isClosed=!0;const e=(0,ct.d9)(s);return this._processMultipath(e.rings),e}if((0,W.l9)(s)){this._isClosed=!1;const e=(0,ct.d9)(s);return this._processMultipath(e.paths),e}if((0,W.YX)(s)){if(this._maxCosAngle)return s;this._isClosed=!0;const e=[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]];return this._processPath(e),{rings:[e]}}s=this._inputGeometries.next()}return null}_processMultipath(s){if(s)for(const e of s)this._processPath(e)}_processPath(s){if(s){let e,i,o,a,r,c,h=s.length,u=s[0];this._isClosed&&++h;for(let p=1;p<h;++p){let g;g=this._isClosed&&p===h-1?s[0]:s[p];const L=g[0]-u[0],A=g[1]-u[1],F=Math.sqrt(L*L+A*A);p>1&&F>0&&o>0&&(e*L+i*A)/F/o<=this._maxCosAngle&&(0,J.qh)(u,1),1===p&&(a=L,r=A,c=F),F>0&&(u=g,e=L,i=A,o=F)}this._isClosed&&o>0&&c>0&&(e*a+i*r)/c/o<=this._maxCosAngle&&(0,J.qh)(s[0],1)}}}var M=z(7547);const bt=.03;class U{constructor(){this._path=[]}path(){return this._path}addPath(s,e){e||s.reverse(),Array.prototype.push.apply(this._path,s),e||s.reverse()}static mergePath(s,e){e&&Array.prototype.push.apply(s,e)}startPath(s){this._path.push(s)}lineTo(s){this._path.push(s)}close(){const s=this._path;s.length>1&&(s[0][0]===s[s.length-1][0]&&s[0][1]===s[s.length-1][1]||s.push([s[0][0],s[0][1]]))}}class I{constructor(s=0,e=!1){}normalize(s){const e=Math.sqrt(s[0]*s[0]+s[1]*s[1]);s[0]/=e,s[1]/=e}calculateLength(s,e){const i=e[0]-s[0],o=e[1]-s[1];return Math.sqrt(i*i+o*o)}calculateSegLength(s,e){return this.calculateLength(s[e],s[e+1])}calculatePathLength(s){let e=0;const i=s?s.length:0;for(let o=0;o<i-1;++o)e+=this.calculateSegLength(s,o);return e}calculatePathArea(s){let e=0;const i=s?s.length:0;for(let o=0;o<i-1;++o)e+=(s[o+1][0]-s[o][0])*(s[o+1][1]+s[o][1]);return e/2}getCoord2D(s,e,i){return[s[0]+(e[0]-s[0])*i,s[1]+(e[1]-s[1])*i]}getSegCoord2D(s,e,i){return this.getCoord2D(s[e],s[e+1],i)}getAngle(s,e,i){return Math.atan2(e[1]-s[1],e[0]-s[0])}getSegAngle(s,e,i){return this.getAngle(s[e],s[e+1],i)}getAngleCS(s,e,i){const o=e[0]-s[0],a=e[1]-s[1],r=Math.sqrt(o*o+a*a);return r>0?[o/r,a/r]:[1,0]}getSegAngleCS(s,e,i){return this.getAngleCS(s[e],s[e+1],i)}cut(s,e,i,o){return[i<=0?s[e]:this.getSegCoord2D(s,e,i),o>=1?s[e+1]:this.getSegCoord2D(s,e,o)]}addSegment(s,e,i){i&&s.push(e[0]),s.push(e[1])}getSubCurve(s,e,i){const o=[];return this.appendSubCurve(o,s,e,i)?o:null}appendSubCurve(s,e,i,o){const a=e?e.length-1:0;let r=0,c=!0,h=0;for(;h<a;){const u=this.calculateSegLength(e,h);if(0!==u){if(c){if(r+u>i){let g=1,L=!1;r+u>=o&&(g=(o-r)/u,L=!0);const A=this.cut(e,h,(i-r)/u,g);if(A&&this.addSegment(s,A,c),L)break;c=!1}}else{if(r+u>o){const p=this.cut(e,h,0,(o-r)/u);p&&this.addSegment(s,p,c);break}this.addSegment(s,[e[h],e[h+1]],c)}r+=u,++h}else++h}return!0}getCIMPointAlong(s,e){const i=s?s.length-1:0;let o=0,a=-1;for(;a<i;){++a;const r=this.calculateSegLength(s,a);if(0!==r){if(o+r>e)return this.getCoord2D(s[a],s[a+1],(e-o)/r);o+=r}}return null}isEmpty(s,e){if(!s||s.length<=1)return!0;const i=s?s.length-1:0;let o=-1;for(;o<i;)if(++o,s[o+1][0]!==s[o][0]||s[o+1][1]!==s[o][1]||e&&s[o+1][2]!==s[o][2])return!1;return!0}offset(s,e,i,o,a){if(!s||s.length<2)return null;let r=0,c=s[r++],h=r;for(;r<s.length;){const L=s[r];L[0]===c[0]&&L[1]===c[1]||(r!==h&&(s[h]=s[r]),c=s[h++]),r++}const u=s[0][0]===s[h-1][0]&&s[0][1]===s[h-1][1];if(u&&--h,h<(u?3:2))return null;const p=[];c=u?s[h-1]:null;let g=s[0];for(let L=0;L<h;L++){const A=L===h-1?u?s[0]:null:s[L+1];if(c)if(A){const F=[A[0]-g[0],A[1]-g[1]];this.normalize(F);const B=[g[0]-c[0],g[1]-c[1]];this.normalize(B);const q=B[0]*F[1]-B[1]*F[0],Rt=B[0]*F[0]+B[1]*F[1];if(q>=0==e<=0){if(Rt<1){const vt=[F[0]-B[0],F[1]-B[1]];this.normalize(vt);const St=Math.sqrt((1+Rt)/2);if(St>1/o){const yt=-Math.abs(e)/St;p.push([g[0]-vt[0]*yt,g[1]-vt[1]*yt])}}}else switch(i){case M.id.Mitered:{const vt=Math.sqrt((1+Rt)/2);if(vt>0&&1/vt<o){const St=[F[0]-B[0],F[1]-B[1]];this.normalize(St);const yt=Math.abs(e)/vt;p.push([g[0]-St[0]*yt,g[1]-St[1]*yt]);break}}case M.id.Bevelled:p.push([g[0]+B[1]*e,g[1]-B[0]*e]),p.push([g[0]+F[1]*e,g[1]-F[0]*e]);break;case M.id.Rounded:if(Rt<1){p.push([g[0]+B[1]*e,g[1]-B[0]*e]);const vt=Math.floor(2.5*(1-Rt));if(vt>0){const St=1/vt;let yt=St;for(let Wt=1;Wt<vt;Wt++,yt+=St){const Gt=[B[1]*(1-yt)+F[1]*yt,-B[0]*(1-yt)-F[0]*yt];this.normalize(Gt),p.push([g[0]+Gt[0]*e,g[1]+Gt[1]*e])}}p.push([g[0]+F[1]*e,g[1]-F[0]*e])}break;default:if(q<0)p.push([g[0]+(B[1]+B[0])*e,g[1]+(B[1]-B[0])*e]),p.push([g[0]+(F[1]-F[0])*e,g[1]-(F[0]+F[1])*e]);else{const vt=Math.sqrt((1+Math.abs(Rt))/2),St=[F[0]-B[0],F[1]-B[1]];this.normalize(St);const yt=e/vt;p.push([g[0]-St[0]*yt,g[1]-St[1]*yt])}}}else{const F=[g[0]-c[0],g[1]-c[1]];this.normalize(F),p.push([g[0]+F[1]*e,g[1]-F[0]*e])}else{const F=[A[0]-g[0],A[1]-g[1]];this.normalize(F),p.push([g[0]+F[1]*e,g[1]-F[0]*e])}c=g,g=A}return p.length<(u?3:2)?null:(u&&p.push([p[0][0],p[0][1]]),p)}}const V=1.7320508075688772,nt=M.TF.OpenEnded;let Z=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new $(e,i,o)}}return _.instance=null,_})();class $ extends J.zY{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new I,this._width=(void 0!==e.width?e.width:5)*i,this._arrowType=void 0!==e.geometricEffectArrowType?e.geometricEffectArrowType:void 0!==e.arrowType?e.arrowType:nt,this._offsetFlattenError=bt*i}processPath(s){switch(this._arrowType){case M.TF.OpenEnded:default:return this._constructSimpleArrow(s,!0);case M.TF.Block:return this._constructSimpleArrow(s,!1);case M.TF.Crossed:return this._constructCrossedArrow(s)}}_constructSimpleArrow(s,e){const i=this._curveHelper.calculatePathLength(s);let o=this._width;i<2*o&&(o=i/2);const a=this._curveHelper.getSubCurve(s,0,i-o);if(!a)return null;const r=o/2;if(this._curveHelper.isEmpty(a,!1))return null;const c=this._constructOffset(a,-r);if(!c)return null;const h=this._constructOffset(a,r);if(!h)return null;const u=this._constructArrowBasePoint(c,-r/2);if(!u)return null;const p=this._constructArrowBasePoint(h,r/2);if(!p)return null;const g=s[s.length-1];e||(this._makeControlPoint(h,!0),this._makeControlPoint(c,!0));const L=new U;return L.addPath(h,!0),L.lineTo(p),this._makeControlPoint(L.path()),L.lineTo(g),this._makeControlPoint(L.path()),L.lineTo(u),this._makeControlPoint(L.path()),L.addPath(c,!1),e?{paths:[L.path()]}:(L.close(),{rings:[L.path()]})}_constructCrossedArrow(s){const e=this._curveHelper.calculatePathLength(s);let i=this._width;e<i*(1+V+1)&&(i=e/(1+V+1));const o=this._curveHelper.getSubCurve(s,0,e-i*(1+V));if(!o)return null;const a=i/2;if(this._curveHelper.isEmpty(o,!1))return null;const r=this._constructOffset(o,a);if(!r)return null;const c=this._constructOffset(o,-a);if(!c)return null;const h=this._curveHelper.getSubCurve(s,0,e-i);if(!h||this._curveHelper.isEmpty(h,!1))return null;const u=this._constructOffset(h,a);if(!u)return null;const p=this._constructOffset(h,-a);if(!p)return null;const g=u[u.length-1],L=this._constructArrowBasePoint(u,a/2);if(!L)return null;const A=p[p.length-1],F=this._constructArrowBasePoint(p,-a/2);if(!F)return null;const B=s[s.length-1];this._makeControlPoint(r,!1),this._makeControlPoint(c,!1);const q=new U;return q.addPath(r,!0),this._makeControlPoint(q.path()),q.lineTo(A),q.lineTo(F),this._makeControlPoint(q.path()),q.lineTo(B),this._makeControlPoint(q.path()),q.lineTo(L),this._makeControlPoint(q.path()),q.lineTo(g),this._makeControlPoint(q.path()),q.addPath(c,!1),{paths:[q.path()]}}_constructOffset(s,e){return this._curveHelper.offset(s,e,M.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(s,e){if(!s||s.length<2)return null;const i=s[s.length-2],o=s[s.length-1],a=[o[0]-i[0],o[1]-i[1]];return this._curveHelper.normalize(a),[o[0]+a[1]*e,o[1]-a[0]*e]}_makeControlPoint(s,e=!1){(0,J.qh)(e?s[0]:s[s.length-1],1)}}let pt=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new Et(e,i,o,a)}}return _.instance=null,_})();class Et{constructor(s,e,i,o){this._inputGeometries=s,this._curveHelper=new I,this._size=(void 0!==e.size?e.size:1)*i,this._offsetFlattenError=bt*i}next(){let s=this._inputGeometries.next();for(;s;){if((0,W.YX)(s))if(this._size>0){const i=this._curveHelper.offset([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]],this._size,M.id.Rounded,4,this._offsetFlattenError);if(i)return{rings:[i]}}else{if(!(this._size<0))return s;if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)+2*this._size>0)return{xmin:s.xmin-this._size,xmax:s.xmax+this._size,ymin:s.ymin-this._size,ymax:s.ymax+this._size}}if((0,W.oU)(s)){if(0===this._size)return s;const e=[];for(const i of s.rings){const o=this._curveHelper.offset(i,this._size,M.id.Rounded,4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{rings:e}}if((0,W.l9)(s)&&this._size>0){const e=[];for(const i of s.paths)if(i&&i.length>1){const o=this._curveHelper.offset(i,this._size,M.id.Rounded,4,this._offsetFlattenError),a=this._curveHelper.offset(i,-this._size,M.id.Rounded,4,this._offsetFlattenError);if(o&&a){for(let r=a.length-1;r>=0;r--)o.push(a[r]);o.push([o[0][0],o[0][1]]),e.push(o)}}if(e.length)return{rings:e}}(0,W.wp)(s),s=this._inputGeometries.next()}return null}}let dt=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new Lt(e,i,o)}}return _.instance=null,_})();class Lt{constructor(s,e,i){var o;this._default_point_size=20,this._inputGeometries=s,this._geomUnitsPerPoint=i,this._rule=null!=(o=e.rule)?o:M.Em.FullGeometry,this._default_size=this._default_point_size*i}next(){let s;for(;s=this._inputGeometries.next();){let e;if((0,W.wp)(s)?e=this._processGeom([[[s.x,s.y]]]):(0,W.aW)(s)?e=this._processGeom([s.points]):(0,W.l9)(s)?e=this._processGeom(s.paths):(0,W.oU)(s)&&(e=this._processGeom(s.rings)),e&&e.length)return{paths:e}}return null}_clone(s){return[s[0],s[1]]}_mid(s,e){return[(s[0]+e[0])/2,(s[1]+e[1])/2]}_mix(s,e,i,o){return[s[0]*e+i[0]*o,s[1]*e+i[1]*o]}_add(s,e){return[s[0]+e[0],s[1]+e[1]]}_add2(s,e,i){return[s[0]+e,s[1]+i]}_sub(s,e){return[s[0]-e[0],s[1]-e[1]]}_dist(s,e){return Math.sqrt((s[0]-e[0])*(s[0]-e[0])+(s[1]-e[1])*(s[1]-e[1]))}_norm(s){return Math.sqrt(s[0]*s[0]+s[1]*s[1])}_normalize(s,e=1){const i=e/this._norm(s);s[0]*=i,s[1]*=i}_leftPerpendicular(s){const i=s[0];s[0]=-s[1],s[1]=i}_leftPerp(s){return[-s[1],s[0]]}_rightPerpendicular(s){const i=-s[0];s[0]=s[1],s[1]=i}_rightPerp(s){return[s[1],-s[0]]}_dotProduct(s,e){return s[0]*e[0]+s[1]*e[1]}_crossProduct(s,e){return s[0]*e[1]-s[1]*e[0]}_rotateDirect(s,e,i){const a=s[0]*i+s[1]*e;s[0]=s[0]*e-s[1]*i,s[1]=a}_makeCtrlPt(s){const e=[s[0],s[1]];return(0,J.qh)(e,1),e}_addAngledTicks(s,e,i,o){const a=this._sub(i,e);this._normalize(a);const r=this._crossProduct(a,this._sub(o,e));let c;c=r>0?this._rightPerp(a):this._leftPerp(a);const h=Math.abs(r)/2,u=[];u.push([e[0]+(c[0]-a[0])*h,e[1]+(c[1]-a[1])*h]),u.push(e),u.push(i),u.push([i[0]+(c[0]+a[0])*h,i[1]+(c[1]+a[1])*h]),s.push(u)}_addBezier2(s,e,i,o,a){if(0==a--)return void s.push(o);const r=this._mid(e,i),c=this._mid(i,o),h=this._mid(r,c);this._addBezier2(s,e,r,h,a),this._addBezier2(s,h,c,o,a)}_addBezier3(s,e,i,o,a,r){if(0==r--)return void s.push(a);const c=this._mid(e,i),h=this._mid(i,o),u=this._mid(o,a),p=this._mid(c,h),g=this._mid(h,u),L=this._mid(p,g);this._addBezier3(s,e,c,p,L,r),this._addBezier3(s,L,g,u,a,r)}_add90DegArc(s,e,i,o,a){const r=null!=a?a:this._crossProduct(this._sub(i,e),this._sub(o,e))>0,c=this._mid(e,i),h=this._sub(c,e);r?this._leftPerpendicular(h):this._rightPerpendicular(h),c[0]+=h[0],c[1]+=h[1],this._addBezier3(s,e,this._mix(e,.33333,c,.66667),this._mix(i,.33333,c,.66667),i,4)}_addArrow(s,e,i){const o=e[0],a=e[1],r=e[e.length-1],c=this._sub(o,a);this._normalize(c);const h=this._crossProduct(c,this._sub(r,a)),u=.5*h,p=this._leftPerp(c),g=[r[0]-p[0]*h,r[1]-p[1]*h],L=e.length-1,A=[];A.push(i?[-p[0],-p[1]]:p);let F=[-c[0],-c[1]];for(let B=1;B<L-1;B++){const q=this._sub(e[B+1],e[B]);this._normalize(q);const Rt=this._dotProduct(q,F),vt=this._crossProduct(q,F),St=Math.sqrt((1+Rt)/2),yt=this._sub(q,F);this._normalize(yt),yt[0]/=St,yt[1]/=St,A.push(vt<0?[-yt[0],-yt[1]]:yt),F=q}A.push(this._rightPerp(F));for(let B=A.length-1;B>0;B--)s.push([e[B][0]+A[B][0]*u,e[B][1]+A[B][1]*u]);s.push([g[0]+A[0][0]*u,g[1]+A[0][1]*u]),s.push([g[0]+A[0][0]*h,g[1]+A[0][1]*h]),s.push(o),s.push([g[0]-A[0][0]*h,g[1]-A[0][1]*h]),s.push([g[0]-A[0][0]*u,g[1]-A[0][1]*u]);for(let B=1;B<A.length;B++)s.push([e[B][0]-A[B][0]*u,e[B][1]-A[B][1]*u])}_cp2(s,e,i){return s.length>=2?s[1]:this._add2(s[0],e*this._default_size,i*this._default_size)}_cp3(s,e,i,o){if(s.length>=3)return s[2];const a=this._mix(s[0],1-i,e,i),r=this._sub(e,s[0]);return this._normalize(r),this._rightPerpendicular(r),[a[0]+r[0]*o*this._default_size,a[1]+r[1]*o*this._default_size]}_arrowPath(s){if(s.length>2)return s;const e=s[0],i=this._cp2(s,-4,0),o=this._sub(e,i);this._normalize(o);const a=this._rightPerp(o);return[e,i,[e[0]+(a[0]-o[0])*this._default_size,e[1]+(a[1]-o[1])*this._default_size]]}_arrowLastSeg(s){const e=s[0],i=this._cp2(s,-4,0);let o;if(s.length>=3)o=s[s.length-1];else{const a=this._sub(e,i);this._normalize(a);const r=this._rightPerp(a);o=[e[0]+(r[0]-a[0])*this._default_size,e[1]+(r[1]-a[1])*this._default_size]}return[i,o]}_processGeom(s){if(!s)return null;const e=[];for(const i of s){if(!i||0===i.length)continue;const o=i.length;let a=i[0];switch(this._rule){case M.Em.PerpendicularFromFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=[];h.push(c),h.push(this._mid(a,r)),e.push(h);break}case M.Em.ReversedFirstSegment:{const r=this._cp2(i,0,-1);e.push([r,a]);break}case M.Em.PerpendicularToSecondSegment:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=[];h.push(this._mid(r,c)),h.push(a),e.push(h);break}case M.Em.SecondSegmentWithTicks:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);let u;u=this._crossProduct(h,this._sub(a,r))>0?this._rightPerp(u):this._leftPerp(h);const p=[];p.push([r[0]+(u[0]-h[0])/3,r[1]+(u[1]-h[1])/3]),p.push(r),p.push(c),p.push([c[0]+(u[0]+h[0])/3,c[1]+(u[1]+h[1])/3]),e.push(p);break}case M.Em.DoublePerpendicular:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,3),h=this._mid(a,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(a,c));this._leftPerpendicular(u);const g=[];g.push(a),g.push([c[0]+u[0]*p,c[1]+u[1]*p]),e.push(g);const L=[];L.push([c[0]-u[0]*p,c[1]-u[1]*p]),L.push(r),e.push(L);break}case M.Em.OppositeToFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,3),h=this._mid(a,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(a,c));this._leftPerpendicular(u);const g=[];g.push([c[0]+u[0]*p,c[1]+u[1]*p]),g.push([c[0]-u[0]*p,c[1]-u[1]*p]),e.push(g);break}case M.Em.TriplePerpendicular:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=this._mid(a,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(a,c));this._leftPerpendicular(u);const g=[];g.push([c[0]+u[0]*p*.8,c[1]+u[1]*p*.8]),g.push([h[0]+.8*(a[0]-h[0]),h[1]+.8*(a[1]-h[1])]),e.push(g),e.push([c,h]);const L=[];L.push([c[0]-u[0]*p*.8,c[1]-u[1]*p*.8]),L.push([h[0]+.8*(r[0]-h[0]),h[1]+.8*(r[1]-h[1])]),e.push(L);break}case M.Em.HalfCircleFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=this._mid(a,r);let u=this._sub(r,a);const p=Math.cos(Math.PI/18),g=Math.sin(Math.PI/18),L=Math.sqrt((1+p)/2),A=Math.sqrt((1-p)/2),F=[];let B;this._crossProduct(u,this._sub(c,a))>0?(F.push(a),u=this._sub(a,h),B=r):(F.push(r),u=this._sub(r,h),B=a),this._rotateDirect(u,L,A),u[0]/=L,u[1]/=L;for(let q=1;q<=18;q++)F.push(this._add(h,u)),this._rotateDirect(u,p,g);F.push(B),e.push(F);break}case M.Em.HalfCircleSecondSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,1,-1);let h=this._sub(a,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r))/2;this._leftPerpendicular(h);const p=[r[0]+h[0]*u,r[1]+h[1]*u];h=this._sub(r,p);const g=Math.cos(Math.PI/18);let L=Math.sin(Math.PI/18);u>0&&(L=-L);const A=[r];for(let F=1;F<=18;F++)this._rotateDirect(h,g,L),A.push(this._add(p,h));e.push(A);break}case M.Em.HalfCircleExtended:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,1,-1);let h;if(o>=4)h=i[3];else{const F=this._sub(a,r);h=this._add(c,F)}const u=this._dist(r,c)/2/.75,p=this._sub(r,a);this._normalize(p,u);const g=this._sub(c,h);this._normalize(g,u),e.push([h,c]);const A=[this._clone(c)];this._addBezier3(A,c,this._add(c,g),this._add(r,p),r,4),A.push(a),e.push(A);break}case M.Em.OpenCircle:{const r=this._cp2(i,-2,0),c=this._sub(r,a),h=Math.cos(Math.PI/18),u=-Math.sin(Math.PI/18),p=[r];for(let g=1;g<=33;g++)this._rotateDirect(c,h,u),p.push(this._add(a,c));e.push(p);break}case M.Em.CoverageEdgesWithTicks:{const r=this._cp2(i,0,-1);let c,h;if(o>=3)c=i[2];else{const L=this._sub(r,a),A=this._leftPerp(L);c=[a[0]+A[0]-.25*L[0],a[1]+A[1]-.25*L[1]]}if(o>=4)h=i[3];else{const L=this._mid(a,r),A=this._sub(a,r);this._normalize(A),this._leftPerpendicular(A);const F=this._crossProduct(A,this._sub(c,L));this._rightPerpendicular(A),h=[c[0]+A[0]*F*2,c[1]+A[1]*F*2]}const u=this._sub(r,a);let p,g;p=this._crossProduct(u,this._sub(c,a))>0?this._rightPerp(u):this._leftPerp(u),g=[],g.push(c),g.push(a),g.push([a[0]+(p[0]-u[0])/3,a[1]+(p[1]-u[1])/3]),e.push(g),p=this._crossProduct(u,this._sub(h,r))>0?this._rightPerp(p):this._leftPerp(u),g=[],g.push([r[0]+(p[0]+u[0])/3,r[1]+(p[1]+u[1])/3]),g.push(r),g.push(h),e.push(g);break}case M.Em.GapExtentWithDoubleTicks:{const r=this._cp2(i,0,2),c=this._cp3(i,r,0,1);let h;if(o>=4)h=i[3];else{const u=this._sub(r,a);h=this._add(c,u)}this._addAngledTicks(e,a,r,this._mid(c,h)),this._addAngledTicks(e,c,h,this._mid(a,r));break}case M.Em.GapExtentMidline:{const r=this._cp2(i,2,0),c=this._cp3(i,r,0,1);let h;if(o>=4)h=i[3];else{const p=this._sub(r,a);h=this._add(c,p)}const u=[];u.push(this._mid(a,c)),u.push(this._mid(r,h)),e.push(u);break}case M.Em.Chevron:{const r=this._cp2(i,-1,-1);let c;if(o>=3)c=i[2];else{const h=this._sub(r,a);this._leftPerpendicular(h),c=this._add(a,h)}e.push([r,this._makeCtrlPt(a),c]);break}case M.Em.PerpendicularWithArc:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,.5,-1);let h=this._sub(r,a);const u=this._norm(h);h[0]/=u,h[1]/=u;const p=this._crossProduct(h,this._sub(c,a));let g=this._dotProduct(h,this._sub(c,a));g<.05*u?g=.05*u:g>.95*u&&(g=.95*u);const L=[a[0]+h[0]*g,a[1]+h[1]*g];this._leftPerpendicular(h);let A=[];A.push([L[0]-h[0]*p,L[1]-h[1]*p]),A.push([L[0]+h[0]*p,L[1]+h[1]*p]),e.push(A);const F=[r[0]+h[0]*p,r[1]+h[1]*p];h=this._sub(r,F);const B=Math.cos(Math.PI/18);let q=Math.sin(Math.PI/18);p<0&&(q=-q),A=[a,r];for(let Rt=1;Rt<=9;Rt++)this._rotateDirect(h,B,q),A.push(this._add(F,h));e.push(A);break}case M.Em.ClosedHalfCircle:{const r=this._cp2(i,2,0),c=this._mid(a,r),h=this._sub(r,c),u=Math.cos(Math.PI/18),p=Math.sin(Math.PI/18),g=[a,r];for(let L=1;L<=18;L++)this._rotateDirect(h,u,p),g.push(this._add(c,h));e.push(g);break}case M.Em.TripleParallelExtended:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,1,-2),h=this._mid(a,r),u=this._sub(c,r);this._normalize(u);const p=Math.abs(this._crossProduct(u,this._sub(h,r)))/2,g=this._dist(r,c),L=[r,a];L.push([a[0]+u[0]*g*.5,a[1]+u[1]*g*.5]),e.push(L);const A=[];A.push([h[0]-u[0]*p,h[1]-u[1]*p]),A.push([h[0]+u[0]*g*.375,h[1]+u[1]*g*.375]),(0,J.qh)(A[A.length-1],1),A.push([h[0]+u[0]*g*.75,h[1]+u[1]*g*.75]),e.push(A),e.push([r,c]);break}case M.Em.ParallelWithTicks:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(c,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,a));this._leftPerpendicular(h),this._addAngledTicks(e,a,r,c),this._addAngledTicks(e,this._mix(a,1,h,u),this._mix(r,1,h,u),this._mid(a,r));break}case M.Em.Parallel:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,a);this._normalize(h);const u=this._leftPerp(h),p=this._crossProduct(h,this._sub(c,a));let g=[a,r];e.push(g),g=[],g.push([a[0]+u[0]*p,a[1]+u[1]*p]),g.push([r[0]+u[0]*p,r[1]+u[1]*p]),e.push(g);break}case M.Em.PerpendicularToFirstSegment:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._mid(a,r),u=this._sub(r,a);this._normalize(u);const p=this._crossProduct(u,this._sub(c,a));this._leftPerpendicular(u);const g=[];g.push([h[0]-u[0]*p*.25,h[1]-u[1]*p*.25]),g.push([h[0]+u[0]*p*1.25,h[1]+u[1]*p*1.25]),e.push(g);break}case M.Em.ParallelOffset:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,a);this._normalize(h);const u=this._crossProduct(h,this._sub(c,a));this._leftPerpendicular(h);const p=[];p.push([a[0]-h[0]*u,a[1]-h[1]*u]),p.push([r[0]-h[0]*u,r[1]-h[1]*u]),e.push(p);const g=[];g.push([a[0]+h[0]*u,a[1]+h[1]*u]),g.push([r[0]+h[0]*u,r[1]+h[1]*u]),e.push(g);break}case M.Em.OffsetOpposite:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,a);this._normalize(h);const u=this._crossProduct(h,this._sub(c,a));this._leftPerpendicular(h);const p=[];p.push([a[0]-h[0]*u,a[1]-h[1]*u]),p.push([r[0]-h[0]*u,r[1]-h[1]*u]),e.push(p);break}case M.Em.OffsetSame:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,a);this._normalize(h);const u=this._crossProduct(h,this._sub(c,a));this._leftPerpendicular(h);const p=[];p.push([a[0]+h[0]*u,a[1]+h[1]*u]),p.push([r[0]+h[0]*u,r[1]+h[1]*u]),e.push(p);break}case M.Em.CircleWithArc:{let r=this._cp2(i,3,0);const c=this._cp3(i,r,.5,-1);let h,u;if(o>=4)h=i[3],u=this._crossProduct(this._sub(h,r),this._sub(c,r))>0;else{h=r,u=this._crossProduct(this._sub(h,a),this._sub(c,a))>0;const F=24*this._geomUnitsPerPoint,B=this._sub(h,a);this._normalize(B,F);const q=Math.sqrt(2)/2;this._rotateDirect(B,q,u?q:-q),r=this._add(a,B)}const p=this._sub(r,a),g=Math.cos(Math.PI/18),L=Math.sin(Math.PI/18),A=[r];for(let F=1;F<=36;F++)this._rotateDirect(p,g,L),A.push(this._add(a,p));this._add90DegArc(A,r,h,c,u),(0,J.qh)(A[A.length-8],1),e.push(A);break}case M.Em.DoubleJog:{let r,c,h=this._cp2(i,-3,1);if(r=o>=3?i[2]:this._add(a,this._sub(a,h)),o>=4)c=i[3];else{const Rt=a;a=h,c=r;const vt=this._dist(a,Rt),St=this._dist(c,Rt);let yt=30*this._geomUnitsPerPoint;.5*vt<yt&&(yt=.5*vt),.5*St<yt&&(yt=.5*St),h=this._mix(a,yt/vt,Rt,(vt-yt)/vt),r=this._mix(c,yt/St,Rt,(St-yt)/St)}const u=this._mid(a,h),p=this._mid(c,r),g=this._dist(a,h),L=this._dist(r,c);let A=Math.min(g,L)/8;A=Math.min(A,24*this._geomUnitsPerPoint);const F=Math.cos(Math.PI/4);let B=this._sub(a,h);this._normalize(B,A),this._crossProduct(B,this._sub(c,h))>0?this._rotateDirect(B,F,-F):this._rotateDirect(B,F,F);let q=[];q.push(h),q.push(this._add(u,B)),q.push(this._sub(u,B)),q.push(a),e.push(q),B=this._sub(c,r),this._normalize(B,A),this._crossProduct(B,this._sub(a,r))<0?this._rotateDirect(B,F,F):this._rotateDirect(B,F,-F),q=[],q.push(r),q.push(this._add(p,B)),q.push(this._sub(p,B)),q.push(c),e.push(q);break}case M.Em.PerpendicularOffset:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);this._crossProduct(h,this._sub(a,r))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const u=[h[0]/8,h[1]/8],p=this._sub(this._mid(r,c),u);e.push([p,a]);break}case M.Em.LineExcludingLastSegment:{const r=this._arrowPath(i),c=[];let h=r.length-2;for(;h--;)c.push(r[h]);e.push(c);break}case M.Em.MultivertexArrow:{const r=this._arrowPath(i),c=[];this._addArrow(c,r,!1),e.push(c);break}case M.Em.CrossedArrow:{const r=this._arrowPath(i),c=[];this._addArrow(c,r,!0),e.push(c);break}case M.Em.ChevronArrow:{const[r,c]=this._arrowLastSeg(i),h=10*this._geomUnitsPerPoint,u=this._sub(a,r);this._normalize(u);const p=this._crossProduct(u,this._sub(c,r)),g=this._leftPerp(u),L=[c[0]-g[0]*p*2,c[1]-g[1]*p*2],A=[];A.push([c[0]+u[0]*h,c[1]+u[1]*h]),A.push(a),A.push([L[0]+u[0]*h,L[1]+u[1]*h]),e.push(A);break}case M.Em.ChevronArrowOffset:{const[r,c]=this._arrowLastSeg(i),h=this._sub(a,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r));this._leftPerpendicular(h);const p=[c[0]-h[0]*u,c[1]-h[1]*u],g=[];g.push([p[0]+h[0]*u*.5,p[1]+h[1]*u*.5]),g.push(this._mid(p,a)),g.push([p[0]-h[0]*u*.5,p[1]-h[1]*u*.5]),e.push(g);break}case M.Em.PartialFirstSegment:{const[r,c]=this._arrowLastSeg(i),h=this._sub(a,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r));this._leftPerpendicular(h),e.push([r,[c[0]-h[0]*u,c[1]-h[1]*u]]);break}case M.Em.Arch:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,1),h=this._sub(a,r),u=this._mix(c,1,h,.55),p=this._mix(c,1,h,-.55),g=[a];this._addBezier2(g,a,u,c,4),this._addBezier2(g,c,p,r,4),e.push(g);break}case M.Em.CurvedParallelTicks:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);this._crossProduct(h,this._sub(a,r))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const u=[h[0]/8,h[1]/8],p=this._sub(this._mid(r,c),u),g=this._sub(this._mix(r,.75,c,.25),u),L=this._sub(this._mix(r,.25,c,.75),u),A=[r];this._addBezier2(A,r,g,p,3),this._addBezier2(A,p,L,c,3),e.push(A);for(let F=0;F<8;F++){const B=A[2*F+1],q=[this._clone(B)];q.push(this._add(B,[h[0]/4,h[1]/4])),e.push(q)}break}case M.Em.Arc90Degrees:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,1),h=[r];this._add90DegArc(h,r,a,c),e.push(h);break}default:e.push(i)}}return e}}let Tt=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new It(e,i,o)}}return _.instance=null,_})();class It extends J.zY{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new I,this._beginCut=(void 0!==e.beginCut?e.beginCut:1)*i,this._endCut=(void 0!==e.endCut?e.endCut:1)*i,this._middleCut=(void 0!==e.middleCut?e.middleCut:0)*i,this._invert=void 0!==e.invert&&e.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(s){const e=this._beginCut,i=this._endCut,o=this._middleCut,a=this._curveHelper.calculatePathLength(s),r=[];if(this._invert){if(0!==e||0!==i||0!==o)if(e+i+o>=a)r.push(s);else{let c=this._curveHelper.getSubCurve(s,0,e);c&&r.push(c),c=this._curveHelper.getSubCurve(s,.5*(a-o),.5*(a+o)),c&&r.push(c),c=this._curveHelper.getSubCurve(s,a-i,i),c&&r.push(c)}}else if(0===e&&0===i&&0===o)r.push(s);else if(!(e+i+o>=a))if(0===o){const c=this._curveHelper.getSubCurve(s,e,a-i);c&&r.push(c)}else{let c=this._curveHelper.getSubCurve(s,e,.5*(a-o));c&&r.push(c),c=this._curveHelper.getSubCurve(s,.5*(a+o),a-i),c&&r.push(c)}return 0===r.length?null:{paths:r}}}class Ct{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(s,e,i=!0){if(this._setEmpty(),!s||0===s.length)return!1;for(let o=0;o<s.length;o++){let a=Math.abs(s[o]);i&&a<1e-7&&(a=1e-7),this._values.push(a),this._length+=a}return e&&1&s.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(s){const e=this._values?this._values.length:0;for(let i=0;i<e;++i)this._values[i]*=s;this._length*=s,this.extPtGap*=s,this.ctrlPtGap*=s}addValue(s){this._length+=s,this._values.push(s)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}var x,_;(_=x||(x={}))[_.FAIL=0]="FAIL",_[_.END=1]="END",_[_.CONTINUE=2]="CONTINUE";class N{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(s){s.segment=this.segment,s.segmentLength=this.segmentLength,s.abscissa=this.abscissa,s.isPathEnd=this.isPathEnd,s.isPartEnd=this.isPartEnd}}class Q extends I{constructor(s=0,e=!1){super(s,e),this._tolerance=bt,this._currentPosition=new N}updateTolerance(s){this._tolerance=bt*s}init(s,e,i=!0){return i?(this._patternLength=e.length(),this._partExtPtGap=e.extPtGap,this._partCtrlPtGap=e.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=s,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(s,e=x.FAIL){const i=new N;return!!this._nextPosition(s,i,null,e)&&(i.copyTo(this._currentPosition),!0)}curPointAndAngle(s){s.pt=this._getPoint(this._currentPosition);const[e,i]=this._getAngle(this._currentPosition);s.ca=e,s.sa=i}nextPointAndAngle(s,e,i=x.FAIL){const o=new N;if(!this._nextPosition(s,o,null,i))return!1;o.copyTo(this._currentPosition),e.pt=this._getPoint(o);const[a,r]=this._getAngle(o);return e.ca=a,e.sa=r,!0}nextCurve(s){if(0===s)return null;const e=[],i=new N;return this._nextPosition(s,i,e,x.END)?(i.copyTo(this._currentPosition),e):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(s,e,i,o){if(this._currentPosition.isPathEnd)return!1;let a=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(a/=this._currentPosition.segmentLength),this._currentPosition.copyTo(e);e.abscissa+s*this._partLengthRatio>e.segmentLength+this._tolerance;){if(i){if(0===i.length)if(0===a){const c=this._path[e.segment];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,a));const r=this._path[e.segment+1];i.push([r[0],r[1]])}if(a=0,s-=(e.segmentLength-e.abscissa)/this._partLengthRatio,this._partSegCount)e.segment=this._nextSegment(),e.segmentLength=this.calculateSegLength(this._path,e.segment),e.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return o!==x.FAIL&&(e.segmentLength=this.calculateSegLength(this._path,e.segment),e.isPartEnd=!0,o===x.END?(e.abscissa=e.segmentLength,e.isPathEnd=!0):e.abscissa=e.segmentLength+s,!0);this._currentPosition.copyTo(e)}}if(e.abscissa+=s*this._partLengthRatio,i){if(0===i.length)if(0===a){const c=this._path[e.segment];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,a));const r=e.abscissa/e.segmentLength;if(1===r){const c=this._path[e.segment+1];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,r))}return this._partSegCount||Math.abs(e.abscissa-e.segmentLength)<this._tolerance&&(e.isPathEnd=this._partIsLast,e.isPartEnd=!0),!0}_getPoint(s){if(-1===s.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,s.segment,s.segmentLength<=0?0:s.abscissa/s.segmentLength)}_getAngle(s){if(-1===s.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,s.segment,s.segmentLength<=0?0:s.abscissa/s.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,J.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let s=this._partSegCount;for(;s;)this._previousSegment(),--s;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const e=this._getStartPointIndex();this._ctrlPtBegin=1===(0,J.zv)(this._path[e]);let i=e+this._partSegCount+1;if(i>=this._path.length&&(i=0),this._ctrlPtEnd=1===(0,J.zv)(this._path[i]),this._patternLength>0){const o=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,a=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let r=Math.round((this._partLength-(o+a))/this._patternLength);r<=0&&(r=o+a>0?0:1),this._partLengthRatio=this._partLength/(o+a+r*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let k=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new O(e,i,o)}}return _.instance=null,_})();class O extends J.zY{constructor(s,e,i){var o,a;super(s,!0,!0),this._walker=new Q,this._walker.updateTolerance(i),this._endings=e.lineDashEnding,this._customDashPos=-(null!=(o=e.offsetAlongLine)?o:0)*i,this._offsetAtEnd=(null!=(a=e.customEndingOffset)?a:0)*i,this._pattern=new Ct,this._pattern.init(e.dashTemplate,!0),this._pattern.scale(i)}processPath(s){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[s]};if(!this.iteratePath){let o=!0;switch(this._endings){case M.sj.HalfPattern:case M.sj.HalfGap:default:this._pattern.extPtGap=0;break;case M.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case M.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case M.sj.NoConstraint:this.isClosed||(o=!1);break;case M.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const a=this._walker.calculatePathLength(s);if(this._pattern.isEmpty()||a<.1*this._pattern.length())return{paths:[s]};if(!this._walker.init(s,this._pattern,o))return{paths:[s]}}let e;if(this.iteratePath)e=this._pattern.nextValue();else{let o;switch(this._endings){case M.sj.HalfPattern:default:o=.5*this._pattern.firstValue();break;case M.sj.HalfGap:o=.5*-this._pattern.lastValue();break;case M.sj.FullGap:o=-this._pattern.lastValue();break;case M.sj.FullPattern:o=0;break;case M.sj.NoConstraint:case M.sj.Custom:o=-this._customDashPos}let a=o/this._pattern.length();a-=Math.floor(a),o=a*this._pattern.length(),this._pattern.reset(),e=this._pattern.nextValue();let r=!1;for(;o>=e;)o-=e,e=this._pattern.nextValue(),r=!r;e-=o,r?(this._walker.nextPosition(e),e=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(e),e=this._pattern.nextValue(),this._walker.nextPosition(e),e=this._pattern.nextValue())}let i=this._walker.nextCurve(e);return i?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),U.mergePath(i,this._firstCurve),this._firstCurve=null)):(e=this._pattern.nextValue(),!this._walker.nextPosition(e)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(i=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,i=this._firstCurve,this._firstCurve=null),{paths:[i]}}}let G=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new K(e,i,o)}}return _.instance=null,_})();class K{constructor(s,e,i){switch(this._inputGeometries=s,this._curveHelper=new I,this._width=(void 0!==e.width?e.width:2)*i,e.method){case M.$y.Mitered:default:this._method=M.id.Mitered;break;case M.$y.Bevelled:this._method=M.id.Bevelled;break;case M.$y.Rounded:case M.$y.TrueBuffer:this._method=M.id.Rounded;break;case M.$y.Square:this._method=M.id.Square}this._option=e.option,this._offsetFlattenError=bt*i}next(){let s=this._inputGeometries.next();for(;s;){if((0,W.YX)(s)&&this._width>0){if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)-2*this._width<0)return s;const e=[];return e.push([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]),e.push([[s.xmin+this._width,s.ymin+this._width],[s.xmax-this._width,s.ymin+this._width],[s.xmax-this._width,s.ymax-this._width],[s.xmin+this._width,s.ymax-this._width],[s.xmin+this._width,s.ymin+this._width]]),{rings:e}}if((0,W.oU)(s)&&this._width>0){const e=[];for(const i of s.rings){const o=this._curveHelper.calculatePathLength(i),a=this._curveHelper.offset(i,this._width,this._method,4,this._offsetFlattenError);a&&(o<0&&a.reverse(),e.push(a))}if(e.length)return{rings:e}}s=this._inputGeometries.next()}return null}}let et=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new it(e,i,o)}}return _.instance=null,_})();class it extends J.zY{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new I,this._length=(void 0!==e.length?e.length:20)*i,this._angle=void 0!==e.angle?e.angle:225,this._position=void 0!==e.position?e.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(s){if(this._curveHelper.isEmpty(s,!1))return null;const e=s[0],i=s[s.length-1];this._curveHelper.normalize([i[0]-e[0],i[1]-e[1]]);const a=[e[0]+(i[0]-e[0])*this._position/100,e[1]+(i[1]-e[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let c=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(c=-c),this._mirror=!this._mirror,{paths:[[e,[a[0]-this._length/2*r,a[1]-this._length/2*c],[a[0]+this._length/2*r,a[1]+this._length/2*c],i]]}}}let rt=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new n(e,i,o)}}return _.instance=null,_})();class n{constructor(s,e,i){this._inputGeometries=s,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?-e.offsetY*i:0}next(){let s=this._inputGeometries.next();for(;s;){if((0,W.YX)(s))return{xmin:s.xmin+this._offsetX,xmax:s.xmax+this._offsetX,ymin:s.ymin+this._offsetY,ymax:s.ymax+this._offsetY};if((0,W.oU)(s)){const e=(0,ct.d9)(s);return this._moveMultipath(e.rings,this._offsetX,this._offsetY),e}if((0,W.l9)(s)){const e=(0,ct.d9)(s);return this._moveMultipath(e.paths,this._offsetX,this._offsetY),e}if((0,W.aW)(s)){const e=(0,ct.d9)(s);return this._movePath(e.points,this._offsetX,this._offsetY),e}if((0,W.wp)(s))return{x:s.x+this._offsetX,y:s.y+this._offsetY};s=this._inputGeometries.next()}return null}_moveMultipath(s,e,i){if(s)for(const o of s)this._movePath(o,e,i)}_movePath(s,e,i){if(s)for(const o of s)o[0]+=e,o[1]+=i}}let m=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new b(e,i,o)}}return _.instance=null,_})();class b{constructor(s,e,i){var o;this._inputGeometries=s,this._curveHelper=new I,this._offset=(null!=(o=e.offset)?o:1)*i,this._method=e.method,this._option=e.option,this._offsetFlattenError=bt*i}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._offset)return s;if((0,W.YX)(s)){if(this._method===M.id.Rounded&&this._offset>0){const i=this._curveHelper.offset([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return i?{rings:[i]}:null}if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)+2*this._offset>0)return{xmin:s.xmin-this._offset,xmax:s.xmax+this._offset,ymin:s.ymin-this._offset,ymax:s.ymax+this._offset}}if((0,W.oU)(s)){const e=[];for(const i of s.rings){const o=this._curveHelper.offset(i,-this._offset,this._method,4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{rings:e}}if((0,W.l9)(s)){const e=[];for(const i of s.paths){const o=this._curveHelper.offset(i,-this._offset,this._method,4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{paths:e}}s=this._inputGeometries.next()}return null}}let y=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new w(e,i,o)}}return _.instance=null,_})();class w{constructor(s,e,i){this._inputGeometries=s,this._reverse=void 0===e.reverse||e.reverse}next(){let s=this._inputGeometries.next();for(;s;){if(!this._reverse)return s;if((0,W.l9)(s)){const e=(0,ct.d9)(s);return(0,J.ov)(e.paths),e}s=this._inputGeometries.next()}return null}}var R=z(65401),D=z(32442);let X=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new tt(e,i,o)}}return _.instance=null,_})();class tt{constructor(s,e,i){this._inputGeometries=s,this._rotateAngle=void 0!==e.angle?e.angle*Math.PI/180:0}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._rotateAngle)return s;const e=(0,R.Ue)();(0,D.$P)(e,s);const i=(e[2]+e[0])/2,o=(e[3]+e[1])/2;if((0,W.YX)(s)){const a={rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]};return this._rotateMultipath(a.rings,i,o),a}if((0,W.oU)(s)){const a=(0,ct.d9)(s);return this._rotateMultipath(a.rings,i,o),a}if((0,W.l9)(s)){const a=(0,ct.d9)(s);return this._rotateMultipath(a.paths,i,o),a}if((0,W.aW)(s)){const a=(0,ct.d9)(s);return this._rotatePath(a.points,i,o),a}if((0,W.wp)(s))return s;s=this._inputGeometries.next()}return null}_rotateMultipath(s,e,i){if(s)for(const o of s)this._rotatePath(o,e,i)}_rotatePath(s,e,i){if(s){const o=Math.cos(this._rotateAngle),a=Math.sin(this._rotateAngle);for(const r of s){const c=r[0]-e,h=r[1]-i;r[0]=e+c*o-h*a,r[1]=i+c*a+h*o}}}}let _t=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new ut(e,i,o)}}return _.instance=null,_})();class ut{constructor(s,e,i){this._inputGeometries=s,this._xFactor=void 0!==e.xScaleFactor?e.xScaleFactor:1.15,this._yFactor=void 0!==e.yScaleFactor?e.yScaleFactor:1.15}next(){let s=this._inputGeometries.next();for(;s;){if(1===this._xFactor&&1===this._yFactor)return s;const e=(0,R.Ue)();(0,D.$P)(e,s);const i=(e[2]+e[0])/2,o=(e[3]+e[1])/2;if((0,W.YX)(s)){const a={rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]};return this._scaleMultipath(a.rings,i,o),a}if((0,W.oU)(s)){const a=(0,ct.d9)(s);return this._scaleMultipath(a.rings,i,o),a}if((0,W.l9)(s)){const a=(0,ct.d9)(s);return this._scaleMultipath(a.paths,i,o),a}if((0,W.aW)(s)){const a=(0,ct.d9)(s);return this._scalePath(a.points,i,o),a}if((0,W.wp)(s))return s;s=this._inputGeometries.next()}return null}_scaleMultipath(s,e,i){if(s)for(const o of s)this._scalePath(o,e,i)}_scalePath(s,e,i){if(s)for(const o of s){const r=(o[1]-i)*this._yFactor;o[0]=e+(o[0]-e)*this._xFactor,o[1]=i+r}}}let ht=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new kt(e,i,o)}}return _.instance=null,_})();class kt{constructor(s,e,i){this._inputGeometries=s,this._height=(void 0!==e.amplitude?e.amplitude:2)*i,this._period=(void 0!==e.period?e.period:3)*i,this._style=e.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new Ct,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new Q,this._walker.updateTolerance(i)}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._height||0===this._period)return s;if((0,W.l9)(s)){const e=this._processGeom(s.paths);if(e.length)return{paths:e}}if((0,W.oU)(s)){const e=this._processGeom(s.rings);if(e.length)return{rings:e}}s=this._inputGeometries.next()}return null}_processGeom(s){const e=[];for(const i of s)if(this._walker.init(i,this._pattern))switch(this._style){case M.zQ.Sinus:default:e.push(this._constructCurve(i,!1));break;case M.zQ.Square:e.push(this._constructSquare(i));break;case M.zQ.Triangle:e.push(this._constructTriangle(i));break;case M.zQ.Random:e.push(this._constructCurve(i,!0))}else e.push(i);return e}_constructCurve(s,e){const i=new U,o=this._walker.calculatePathLength(s);let a=Math.round(o/this._period);0===a&&(a=1);const h=this._period/16,u=1/(16*a+1),p=2*Math.PI*o/(o/a),g=2*Math.PI*Math.random(),L=2*Math.PI*Math.random(),A=2*Math.PI*Math.random(),F=.75-Math.random()/2,B=.75-Math.random()/2,q={};this._walker.curPointAndAngle(q),i.startPath(q.pt);let Rt=0;for(;;){if(!this._walker.nextPointAndAngle(h,q)){i.lineTo(s[s.length-1]);break}{const vt=Rt;let St;if(Rt+=u,e){const yt=this._height/2*(1+.3*Math.sin(F*p*vt+g));St=yt*Math.sin(p*vt+L),St+=yt*Math.sin(B*p*vt+A),St/=2}else St=.5*this._height*Math.sin(.5*p*vt);i.lineTo([q.pt[0]-St*q.sa,q.pt[1]+St*q.ca])}}return i.path()}_constructSquare(s){const e=new U,i=this._walker.calculatePathLength(s);Math.round(i/this._period);let o=!0;for(;;){let a=!1;if(this._walker.curPositionIsValid()){const r={};this._walker.curPointAndAngle(r);const c={};if(this._walker.nextPointAndAngle(this._period,c)){const h={};this._walker.nextPointAndAngle(this._period,h)&&(o?(e.startPath(r.pt),o=!1):e.lineTo(r.pt),e.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),e.lineTo([c.pt[0]-this._height/2*c.sa,c.pt[1]+this._height/2*c.ca]),e.lineTo([c.pt[0]+this._height/2*c.sa,c.pt[1]-this._height/2*c.ca]),e.lineTo([h.pt[0]+this._height/2*h.sa,h.pt[1]-this._height/2*h.ca]),a=!0)}}if(!a){e.lineTo(this._walker.getPathEnd());break}}return e.path()}_constructTriangle(s){const e=new U,i=this._walker.calculatePathLength(s);Math.round(i/this._period);let o=!0;for(;;){let a=!1;if(this._walker.curPositionIsValid()){const r={};this._walker.curPointAndAngle(r);const c={};if(this._walker.nextPointAndAngle(this._period/2,c)){const h={};this._walker.nextPointAndAngle(this._period,h)&&(this._walker.nextPosition(this._period/2)&&(o?(e.startPath(r.pt),o=!1):e.lineTo(r.pt),e.lineTo([c.pt[0]-this._height/2*c.sa,c.pt[1]+this._height/2*c.ca]),e.lineTo([h.pt[0]+this._height/2*h.sa,h.pt[1]-this._height/2*h.ca])),a=!0)}}if(!a){e.lineTo(this._walker.getPathEnd());break}}return e.path()}}let T=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new l(e,i,o)}}return _.instance=null,_})();class l extends J.v1{constructor(s,e,i){var o;super(s,!0,!0),this._geometryWalker=new Q,this._geometryWalker.updateTolerance(i),this._angleToLine=null==(o=e.angleToLine)||o,this._offset=(e.offset?e.offset:0)*i,this._originalEndings=e.endings,this._offsetAtEnd=(e.customEndingOffset?e.customEndingOffset:0)*i,this._position=-(e.offsetAlongLine?e.offsetAlongLine:0)*i,this._pattern=new Ct,this._pattern.init(e.placementTemplate,!1),this._pattern.scale(i),this._endings=this._originalEndings}processPath(s){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath)e=this._pattern.nextValue();else{this._endings=this._originalEndings===M.JS.WithFullGap&&this.isClosed?M.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let o,a=!0;switch(this._endings){case M.JS.NoConstraint:o=-this._position,o=this._adjustPosition(o),a=!1;break;case M.JS.WithHalfGap:default:o=-this._pattern.lastValue()/2;break;case M.JS.WithFullGap:o=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case M.JS.WithMarkers:o=0;break;case M.JS.Custom:o=-this._position,o=this._adjustPosition(o),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(s,this._pattern,a))return null;this._pattern.reset();let r=0;for(;o>r;)o-=r,r=this._pattern.nextValue();r-=o,e=r,this.iteratePath=!0}const i={};return this._geometryWalker.nextPointAndAngle(e,i)?this._endings===M.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===M.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine&&this.internalPlacement.setRotateCS(i.ca,i.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(s){let e=s/this._pattern.length();return e-=Math.floor(e),e*this._pattern.length()}}let f=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new d(e,i,o)}}return _.instance=null,_})();class d extends J.v1{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new I,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._type=e.extremityPlacement,this._position=void 0!==e.offsetAlongLine?e.offsetAlongLine*i:0,this._beginProcessed=!1}processPath(s){let e;switch(this._type){case M.Tx.Both:default:this._beginProcessed?(e=this._atExtremities(s,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(e=this._atExtremities(s,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case M.Tx.JustBegin:e=this._atExtremities(s,this._position,!0);break;case M.Tx.JustEnd:e=this._atExtremities(s,this._position,!1);case M.Tx.None:}return e}_atExtremities(s,e,i){const o=s.length;if(o<2)return null;const r=i?o:-1,c=i?1:-1;let h,u=0,p=i?s[0]:s[o-1];for(let g=i?1:o-2;g!==r;g+=c){h=p,p=s[g];const L=this._curveHelper.calculateLength(h,p);if(u+L>e){const A=(e-u)/L,[F,B]=this._curveHelper.getAngleCS(h,p,A),q=(0,J.XV)(h,p,A);return this.internalPlacement.setTranslate(q[0]-this._offset*B,q[1]+this._offset*F),this._angleToLine&&this.internalPlacement.setRotateCS(-F,-B),this.internalPlacement}u+=L}return null}}let v=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new S(e,i,o)}}return _.instance=null,_})();class S extends J.v1{constructor(s,e,i){super(s,!0,!0),this._walker=new Q,this._walker.updateTolerance(i),this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._beginGap=void 0!==e.beginPosition?e.beginPosition*i:0,this._endGap=void 0!==e.endPosition?e.endPosition*i:0,this._flipFirst=void 0===e.flipFirst||e.flipFirst,this._pattern=new Ct,this._pattern.init(e.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(s){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath){const c=this._pattern.nextValue()*this._subPathLen,h=this._beginGap+c;e=h-this._prevPos,this._prevPos=h}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(s)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(s,this._pattern,!1))return null;this._pattern.reset();const c=this._pattern.nextValue()*this._subPathLen,h=this._beginGap+c;e=h-this._prevPos,this._prevPos=h,this.iteratePath=!0}const i={};if(!this._walker.nextPointAndAngle(e,i,x.END))return this.iteratePath=!1,null;let a,r;return this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine?(a=i.ca,r=i.sa):(a=1,r=0),this._isFirst&&this._flipFirst&&(a=-a,r=-r),this.internalPlacement.setRotateCS(a,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var P=z(97373);let C=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new Y(e,i,o,a)}}return _.instance=null,_})();class Y{constructor(s,e,i,o){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._stepX=(void 0!==e.stepX?Math.abs(e.stepX):16)*i,this._stepY=(void 0!==e.stepY?Math.abs(e.stepY):16)*i,0!==this._stepX&&0!==this._stepY&&s&&function E(_){return void 0!==_.rings}(s)&&s.rings){if(this._gridType=void 0!==e.gridType?e.gridType:M.bj.Fixed,this._gridType===M.bj.Random)this._randomness=void 0!==e.randomness?e.randomness/100:1,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0;else{if(this._randomness=0,this._gridAngle=void 0!==e.gridAngle?e.gridAngle:0,this._shiftOddRows=void 0!==e.shiftOddRows&&e.shiftOddRows,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?e.offsetY*i:0,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginX=0,this._graphicOriginY=0,this._internalPlacement=new P.u,this._calculateMinMax(s),this._geometry=s}}next(){return this._geometry?this._nextInside():null}_calculateMinMax(s){let e,i,o,a,r,c,h,u;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,r=c=Number.MAX_VALUE,h=u=-Number.MAX_VALUE;for(const p of s.rings){const g=p?p.length:0;for(let L=0;L<g;++L)e=p[L][0]-this._graphicOriginX-this._offsetX,i=p[L][1]-this._graphicOriginY-this._offsetY,o=this._cosAngle*e-this._sinAngle*i,a=this._sinAngle*e+this._cosAngle*i,r=Math.min(r,o),h=Math.max(h,o),c=Math.min(c,a),u=Math.max(u,a)}r+=this._graphicOriginX,h+=this._graphicOriginX,c+=this._graphicOriginY,u+=this._graphicOriginY,this._xMin=Math.round(r/this._stepX),this._xMax=Math.round(h/this._stepX),this._yMin=Math.round(c/this._stepY),this._yMax=Math.round(u/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let s=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(s+=.5*this._stepX);const e=this._currentY*this._stepY+this._offsetY;let i,o;return this._currentX++,this._gridType===M.bj.Random?(i=this._graphicOriginX+s+this._stepX*this._randomness*(.5-Math.random())*2/3,o=this._graphicOriginY+e+this._stepY*this._randomness*(.5-Math.random())*2/3):(i=this._graphicOriginX+this._cosAngle*s+this._sinAngle*e,o=this._graphicOriginY-this._sinAngle*s+this._cosAngle*e),this._internalPlacement.setTranslate(i,o),this._internalPlacement}}}let st=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new gt(e,i,o)}}return _.instance=null,_})();class gt extends J.v1{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new I,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._relativeTo=e.relativeTo,this._position=void 0!==e.startPointOffset?e.startPointOffset*i:0,this._epsilon=.001*i}processPath(s){const e=this._position;if(this._relativeTo===M.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=s.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const o=this._curSegment;this._curSegment++;const a=s[o-1],r=s[o],c=this._curveHelper.calculateLength(a,r);if(c<this._epsilon)continue;const h=.5+this._position/c,[u,p]=this._curveHelper.getAngleCS(a,r,h),g=(0,J.XV)(a,r,h);return this.internalPlacement.setTranslate(g[0]-this._offset*p,g[1]+this._offset*u),this._angleToLine&&this.internalPlacement.setRotateCS(u,p),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===M.CS.LineEnd&&(0,J.hh)(s);const i=this.onLine(s,e);return this._relativeTo===M.CS.LineEnd&&(0,J.hh)(s),i}onLine(s,e){let i,o=!1;switch(this._relativeTo){case M.CS.LineMiddle:default:i=this._curveHelper.calculatePathLength(s)/2+e;break;case M.CS.LineBeginning:i=e;break;case M.CS.LineEnd:i=e,o=!0}const a=s.length;let r,c=0,h=s[0];for(let u=1;u<a;++u){r=h,h=s[u];const p=this._curveHelper.calculateLength(r,h);if(c+p>i){const g=(i-c)/p,[L,A]=this._curveHelper.getAngleCS(r,h,g),F=(0,J.XV)(r,h,g),B=o?-this._offset:this._offset;return this.internalPlacement.setTranslate(F[0]-B*A,F[1]+B*L),this._angleToLine&&(o?this.internalPlacement.setRotateCS(-L,-A):this.internalPlacement.setRotateCS(L,A)),this.internalPlacement}c+=p}return null}}let ot=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new at(e,i,o)}}return _.instance=null,_})();class at extends J.v1{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new I,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._endPoints=void 0===e.placeOnEndPoints||e.placeOnEndPoints,this._controlPoints=void 0===e.placeOnControlPoints||e.placeOnControlPoints,this._regularVertices=void 0===e.placeOnRegularVertices||e.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(s){if(this.iteratePath||(this._preparePath(s),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const e=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(e[2]);let i=e[0],o=e[1];if(0!==this._offset){const a=Math.cos(e[2]),r=Math.sin(e[2]);i-=this._offset*r,o+=this._offset*a}return this.internalPlacement.setTranslate(i,o),this._tagIterator++,this.internalPlacement}_preparePath(s){this._tags.length=0,this._tagIterator=0;const e=(0,J.QK)(s),i=s.length-1;let o,a,r=0,c=0,h=0,u=0,p=0;for(;r<i;){r++,o=s[r-1],a=s[r];const g=(0,J.zv)(o),L=(0,J.zv)(a);(this._angleToLine||0!==this._offset)&&(u=this._curveHelper.getAngle(o,a,0)),1===r?e?(c=u,h=g):(this._endPoints||this._controlPoints&&1===g)&&this._tags.push([o[0],o[1],u]):1===g?this._controlPoints&&this._tags.push([o[0],o[1],mt(p,u)]):this._regularVertices&&this._tags.push([o[0],o[1],mt(p,u)]),(this._angleToLine||0!==this._offset)&&(p=this._curveHelper.getAngle(o,a,1)),r===i&&(e?1===L||1===h?this._controlPoints&&this._tags.push([a[0],a[1],mt(p,c)]):this._regularVertices&&this._tags.push([a[0],a[1],mt(p,c)]):(this._endPoints||this._controlPoints&&1===L)&&this._tags.push([a[0],a[1],p]))}this._tagIterator=0}}function mt(_,s){const e=Math.PI;for(;Math.abs(s-_)>e+2e-15;)s-_>e?s-=2*e:s+=2*e;return(_+s)/2}let Mt=(()=>{class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,i,o,a){return new Dt(e,i,o)}}return _.instance=null,_})();class Dt{constructor(s,e,i){this._geometry=s,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?e.offsetY*i:0,this._method=void 0!==e.method?e.method:M.Lh.OnPolygon,this._internalPlacement=new P.u}next(){const s=this._geometry;return this._geometry=null,s&&function wt(_){return void 0!==_.rings}(s)?this._polygonCenter(s):null}_polygonCenter(s){let e=!1;switch(this._method){default:{const i=(0,R.Ue)();(0,D.$P)(i,s),this._internalPlacement.setTranslate((i[2]+i[0])/2+this._offsetX,(i[3]+i[1])/2+this._offsetY),e=!0;break}}return e?this._internalPlacement:null}}function Ft(_){if(!_)return null;switch(_.type){case"CIMGeometricEffectAddControlPoints":return lt.local();case"CIMGeometricEffectArrow":return Z.local();case"CIMGeometricEffectBuffer":return pt.local();case"CIMGeometricEffectControlMeasureLine":return dt.local();case"CIMGeometricEffectCut":return Tt.local();case"CIMGeometricEffectDashes":return k.local();case"CIMGeometricEffectDonut":return G.local();case"CIMGeometricEffectJog":return et.local();case"CIMGeometricEffectMove":return rt.local();case"CIMGeometricEffectOffset":return m.local();case"CIMGeometricEffectReverse":return y.local();case"CIMGeometricEffectRotate":return X.local();case"CIMGeometricEffectScale":return _t.local();case"CIMGeometricEffectWave":return ht.local()}return null}function Ot(_){if(!_)return null;switch(_.type){case"CIMMarkerPlacementAlongLineSameSize":return T.local();case"CIMMarkerPlacementAtExtremities":return f.local();case"CIMMarkerPlacementAtRatioPositions":return v.local();case"CIMMarkerPlacementInsidePolygon":return C.local();case"CIMMarkerPlacementOnLine":return st.local();case"CIMMarkerPlacementOnVertices":return ot.local();case"CIMMarkerPlacementPolygonCenter":return Mt.local()}return null}},97373:(At,Pt,z)=>{z.d(Pt,{u:()=>ct});class ct{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rz_c&&0!==this.rz_s)&&(this.rz=Math.atan2(this.rz_s,this.rz_c)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rz_c=1,this.rz_s=0}setTranslate(lt,xt){this.tx=lt,this.ty=xt}setTranslateZ(lt){this.tz=lt}setRotateCS(lt,xt){this.rz=void 0,this.rz_c=lt,this.rz_s=xt}setRotate(lt){this.rz=lt,this.rz_c=void 0,this.rz_s=void 0}setRotateY(lt){this.ry=lt}setScale(lt){this.s=lt}setMeasure(lt){this.m=lt}}},57052:(At,Pt,z)=>{z.d(Pt,{Z:()=>M});var ct=z(15861),W=z(84792),J=z(26584),lt=z(10699);class M{constructor(){this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null}destroy(){this._inFlightResourceMap.clear(),this._resourceMap.clear()}getResource(I){var V;return null!=(V=this._resourceMap.get(I))?V:null}fetchResource(I,V){var j=this;return(0,ct.Z)(function*(){const nt={width:0,height:0},Z=j._resourceMap,$=Z.get(I);if($)return nt.width=$.width,nt.height=$.height,nt;let pt=j._inFlightResourceMap.get(I);return pt||(pt=function bt(U,I){if(U.includes(";base64,")){const V=new Image;return V.src=U,V.decode().then(()=>({ok:!0,value:V})).catch(j=>(0,lt.D_)(j)?{ok:!1,error:j}:{ok:!1,error:new J.Z("invalid-resource",`Could not fetch requested resource at ${U}`)})}return(0,W.default)(U,Ut({responseType:"image"},I)).then(V=>({ok:!0,value:V.data})).catch(V=>(0,lt.D_)(V)?{ok:!1,error:V}:{ok:!1,error:new J.Z("invalid-resource",`Could not fetch requested resource at ${U}`)})}(I,V),j._inFlightResourceMap.set(I,pt),pt=pt.then(Et=>{if(j._inFlightResourceMap.delete(I),Et.ok){Z.set(I,Et.value);const dt=Et.value;return nt.width=dt.width,nt.height=dt.height,nt}return nt}),pt)})()}deleteResource(I){this._inFlightResourceMap.delete(I),this._resourceMap.delete(I)}}},89932:(At,Pt,z)=>{z.d(Pt,{Tu:()=>k,cD:()=>O,et:()=>it,g:()=>et,uQ:()=>Q,x1:()=>K,zA:()=>x});var ct=z(986),W=z(63290),J=z(62208),lt=z(27899),xt=z(23841),M=z(65401),bt=z(32442),U=z(27105),I=z(91179),V=z(29214),j=z(11004),nt=z(97373),Z=z(57052),$=z(7547),pt=z(31375),Et=z(68937),dt=z(61261),Lt=z(39351),Tt=z(25797);const It=Math.PI/180,Ct=W.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class x{constructor(n){this._t=n}static createIdentity(){return new x([1,0,0,0,1,0])}clone(){return new x(this._t.slice())}transform(n){const m=this._t;return[m[0]*n[0]+m[1]*n[1]+m[2],m[3]*n[0]+m[4]*n[1]+m[5]]}static createScale(n,m){return new x([n,0,0,0,m,0])}scale(n,m){const b=this._t;return b[0]*=n,b[1]*=n,b[2]*=n,b[3]*=m,b[4]*=m,b[5]*=m,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(n,m){return new x([0,0,n,0,0,m])}translate(n,m){const b=this._t;return b[2]+=n,b[5]+=m,this}static createRotate(n){const m=Math.cos(n),b=Math.sin(n);return new x([m,-b,0,b,m,0])}rotate(n){return x.multiply(this,x.createRotate(n),this)}static multiply(n,m,b){const y=n._t,w=m._t,D=y[1]*w[0]+y[4]*w[1],X=y[2]*w[0]+y[5]*w[1]+w[2],tt=y[0]*w[3]+y[3]*w[4],_t=y[1]*w[3]+y[4]*w[4],ut=y[2]*w[3]+y[5]*w[4]+w[5],ht=b._t;return ht[0]=y[0]*w[0]+y[3]*w[1],ht[1]=D,ht[2]=X,ht[3]=tt,ht[4]=_t,ht[5]=ut,b}invert(){const n=this._t;let m=n[0]*n[4]-n[1]*n[3];return 0===m?new x([0,0,0,0,0,0]):(m=1/m,new x([n[4]*m,-n[1]*m,(n[1]*n[5]-n[2]*n[4])*m,-n[3]*m,n[0]*m,(n[2]*n[3]-n[0]*n[5])*m]))}}class N{constructor(n,m){this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new lt.Z(nt.u,null,null,100),this._earlyReturn=!1,this._mapRotation=0,this._resourceManager=n||new Z.Z,this._transfos.push(m||x.createIdentity()),this._sizeTransfos.push(m?m.scaleRatio():1)}setTransform(n,m){this._transfos=[n||x.createIdentity()],this._sizeTransfos=[m||(n?n.scaleRatio():1)]}setGeomUnitsPerPoint(n){this._geomUnitsPerPoint=n}transformPt(n){return this._transfos[this._transfos.length-1].transform(n)}transformSize(n){return n*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(n){return this._transfos[this._transfos.length-1].invert().transform(n)}reverseTransformSize(n){return n/this._sizeTransfos[this._sizeTransfos.length-1]}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(n,m){const b=m?n.scaleRatio():1;x.multiply(n,this.back(),n),this._transfos.push(n),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*b)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(n,m){if(n)switch(n.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(n,m);break;case"CIMTextSymbol":this.drawTextSymbol(n,m)}}drawMultiLayerSymbol(n,m){if(!n)return;const b=n.symbolLayers;if(!b)return;const y=n.effects;if(y&&y.length>0){const w=this.executeEffects(y,m);if(w){let R=w.next();for(;R;)this.drawSymbolLayers(b,R),R=w.next()}}else this.drawSymbolLayers(b,m)}executeEffects(n,m){const b=this._resourceManager.geometryEngine;let y=new V.M(m);for(const w of n){const R=(0,j.h)(w);R&&(y=R.execute(y,w,this.geomUnitsPerPoint(),b))}return y}drawSymbolLayers(n,m){let b=n.length;for(;b--;){const y=n[b];if(!y||!1===y.enable)continue;const w=y.effects;if(w&&w.length>0){const R=this.executeEffects(w,m);if(R){let D=null;for(;(D=R.next())&&(this.drawSymbolLayer(y,D),!this._earlyReturn););}}else this.drawSymbolLayer(y,m);if(this._earlyReturn)return}}drawSymbolLayer(n,m){switch(n.type){case"CIMSolidFill":this.drawSolidFill(m,n.color);break;case"CIMHatchFill":this.drawHatchFill(m,n);break;case"CIMPictureFill":this.drawPictureFill(m,n);break;case"CIMGradientFill":this.drawGradientFill(m,n);break;case"CIMSolidStroke":this.drawSolidStroke(m,n.color,n.width,n.capStyle,n.joinStyle,n.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(m,n);break;case"CIMGradientStroke":this.drawGradientStroke(m,n);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(n,m)}}drawHatchFill(n,m){const b=this._buildHatchPolyline(m,n,this.geomUnitsPerPoint());b&&(this.pushClipPath(n),this.drawMultiLayerSymbol(m.lineSymbol,b),this.popClipPath())}drawPictureFill(n,m){}drawGradientFill(n,m){}drawPictureStroke(n,m){}drawGradientStroke(n,m){}drawMarkerLayer(n,m){const b=n.markerPlacement;if(b){const y=(0,j.W)(b);if(y){const w="CIMMarkerPlacementInsidePolygon"===b.type;w&&this.pushClipPath(m);const R=y.execute(m,b,this.geomUnitsPerPoint(),this._resourceManager.geometryEngine);if(R){let D=null;for(;(D=R.next())&&(this.drawMarker(n,D),!this._earlyReturn););}w&&this.popClipPath()}}else{const y=this._placementPool.acquire();if((0,I.wp)(m))y.tx=m.x,y.ty=m.y,this.drawMarker(n,y);else if((0,I.oU)(m))[y.tx,y.ty]=(0,U.tO)(m),this.drawMarker(n,y);else for(const w of m.points)if(y.tx=w[0],y.ty=w[1],this.drawMarker(n,y),this._earlyReturn)break;this._placementPool.release(y)}}drawMarker(n,m){switch(n.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(n,m);break;case"CIMVectorMarker":this.drawVectorMarker(n,m)}}drawPictureMarker(n,m){var b,y,w,R,D;if(!n)return;const X=this._resourceManager.getResource(n.url),tt=null!=(b=n.size)?b:10;if((0,J.Wi)(X)||tt<=0)return;const _t=X.width,ut=X.height;if(!_t||!ut)return;const ht=_t/ut,kt=null!=(y=n.scaleX)?y:1,T=x.createIdentity(),l=n.anchorPoint;if(l){let E=l.x,C=l.y;"Absolute"!==n.anchorPointUnits&&(E*=tt*ht*kt,C*=tt),T.translate(-E,-C)}let f=null!=(w=n.rotation)?w:0;n.rotateClockwise&&(f=-f),this._mapRotation&&(f+=this._mapRotation),f&&T.rotate(f*It);let d=null!=(R=n.offsetX)?R:0,v=null!=(D=n.offsetY)?D:0;if(d||v){if(this._mapRotation){const E=It*this._mapRotation,C=Math.cos(E),Y=Math.sin(E),H=d*Y+v*C;d=d*C-v*Y,v=H}T.translate(d,v)}const S=this.geomUnitsPerPoint();1!==S&&T.scale(S,S);const P=m.getAngle();P&&T.rotate(P),T.translate(m.tx,m.ty),this.push(T,!1),this.drawImage(n.url,tt,n.scaleX),this.pop()}drawVectorMarker(n,m){var b,y,w,R;if(!n)return;const D=n.markerGraphics;if(!D)return;const X=null!=(b=n.size)?b:10,tt=n.frame,_t=tt?tt.ymax-tt.ymin:0,ut=X&&_t?X/_t:1,ht=x.createIdentity();tt&&ht.translate(.5*-(tt.xmax+tt.xmin),.5*-(tt.ymax+tt.ymin));const kt=n.anchorPoint;if(kt){let S=kt.x,P=kt.y;"Absolute"!==n.anchorPointUnits?tt&&(S*=tt.xmax-tt.xmin,P*=tt.ymax-tt.ymin):(S/=ut,P/=ut),ht.translate(-S,-P)}1!==ut&&ht.scale(ut,ut);let T=null!=(y=n.rotation)?y:0;n.rotateClockwise&&(T=-T),this._mapRotation&&(T+=this._mapRotation),T&&ht.rotate(T*It);let l=null!=(w=n.offsetX)?w:0,f=null!=(R=n.offsetY)?R:0;if(l||f){if(this._mapRotation){const S=It*this._mapRotation,P=Math.cos(S),E=Math.sin(S),C=l*E+f*P;l=l*P-f*E,f=C}ht.translate(l,f)}const d=this.geomUnitsPerPoint();1!==d&&ht.scale(d,d);const v=m.getAngle();v&&ht.rotate(v),ht.translate(m.tx,m.ty),this.push(ht,n.scaleSymbolsProportionally);for(const S of D)if(S&&S.symbol&&S.geometry||Ct.error("Invalid marker graphic",S),this.drawSymbol(S.symbol,S.geometry),this._earlyReturn)break;this.pop()}drawTextSymbol(n,m){var b,y,w,R;if(!n||!(0,I.wp)(m)||(null!=(b=n.height)?b:10)<=0)return;const D=x.createIdentity();let X=null!=(y=n.angle)?y:0;X=-X,X&&D.rotate(X*It);const tt=null!=(w=n.offsetX)?w:0,_t=null!=(R=n.offsetY)?R:0;(tt||_t)&&D.translate(tt,_t);const ut=this.geomUnitsPerPoint();1!==ut&&D.scale(ut,ut),D.translate(m.x,m.y),this.push(D,!1),this.drawText(n),this.pop()}_buildHatchPolyline(n,m,b){let y=(void 0!==n.separation?n.separation:4)*b,w=void 0!==n.rotation?n.rotation:0;if(0===y)return null;y<0&&(y=-y);let R=0;const D=.5*y;for(;R>D;)R-=y;for(;R<-D;)R+=y;const X=(0,M.Ue)();(0,bt.$P)(X,m),X[0]-=D,X[1]-=D,X[2]+=D,X[3]+=D;const tt=[[X[0],X[1]],[X[0],X[3]],[X[2],X[3]],[X[2],X[1]]];for(;w>180;)w-=180;for(;w<0;)w+=180;const _t=Math.cos(w*It),ut=Math.sin(w*It),ht=-y*ut,kt=y*_t;let T,l,f,d;R=(void 0!==n.offsetX?n.offsetX*b:0)*ut-(void 0!==n.offsetY?n.offsetY*b:0)*_t,T=f=Number.MAX_VALUE,l=d=-Number.MAX_VALUE;for(const H of tt){const st=H[0],gt=H[1],ot=_t*st+ut*gt,ft=-ut*st+_t*gt;T=Math.min(T,ot),f=Math.min(f,ft),l=Math.max(l,ot),d=Math.max(d,ft)}f=Math.floor(f/y)*y;let v=_t*T-ut*f-ht*R/y,S=ut*T+_t*f-kt*R/y,P=_t*l-ut*f-ht*R/y,E=ut*l+_t*f-kt*R/y;const C=1+Math.round((d-f)/y),Y=[];for(let H=0;H<C;H++)v+=ht,S+=kt,P+=ht,E+=kt,Y.push([[v,S],[P,E]]);return{paths:Y}}}class Q extends N{constructor(n,m){super(n,m),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new pt.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,M.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(n){if(n&&!(this._clipCount>0))if((0,I.oU)(n))this._processPath(n.rings,0);else if((0,I.l9)(n))this._processPath(n.paths,0);else if((0,I.YX)(n)){const m=G(n);m&&this._processPath(m.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(n,m,b){if(!n||this._clipCount>0)return;const y=.5*this.transformSize(b);if((0,I.oU)(n))this._processPath(n.rings,y);else if((0,I.l9)(n))this._processPath(n.paths,y);else if((0,I.YX)(n)){const w=G(n);w&&this._processPath(w.rings,y)}else console.error("drawSolidStroke unexpected geometry type!")}pushClipPath(n){this.drawSolidFill(n),++this._clipCount}popClipPath(){--this._clipCount}drawImage(n,m,b){let y=b*m,w=m;const R=this._resourceManager.getResource(n);!m&&(0,J.pC)(R)&&(y=b*R.width,w=R.height),this._merge(this.transformPt([-y/2,-w/2]),0),this._merge(this.transformPt([-y/2,w/2]),0),this._merge(this.transformPt([y/2,-w/2]),0),this._merge(this.transformPt([y/2,w/2]),0)}drawText(n){this._textRasterizer||(this._textRasterizer=new Et.d)}_processPath(n,m){if(n)for(const b of n){const y=b?b.length:0;if(y>1){this._merge(this.transformPt(b[0]),m);for(let w=1;w<y;++w)this._merge(this.transformPt(b[w]),m)}}}_merge(n,m){n[0]-m<this._xmin&&(this._xmin=n[0]-m),n[0]+m>this._xmax&&(this._xmax=n[0]+m),n[1]-m<this._ymin&&(this._ymin=n[1]-m),n[1]+m>this._ymax&&(this._ymax=n[1]+m)}}class k extends N{constructor(){super(...arguments),this._searchPoint=[0,0],this._searchDistPoint=0}hitTest(n,m,b,y,w,R){const D=R*(0,xt.F2)(1);return this.setTransform(),this.setGeomUnitsPerPoint(D),this._searchPoint=[(n[0]+n[2])/2,(n[1]+n[3])/2],this._searchDistPoint=(n[2]-n[0])/2/D,this._textInfo=y,this._mapRotation=m&&("CIMPointSymbol"===m.type&&"Map"!==m.angleAlignment||"CIMTextSymbol"===m.type)?w:0,this._earlyReturn=!1,this.drawSymbol(m,b),this._earlyReturn}drawSolidFill(n,m){this._hitTestFill(n)}drawHatchFill(n,m){this._hitTestFill(n)}drawPictureFill(n,m){this._hitTestFill(n)}drawGradientFill(n,m){this._hitTestFill(n)}drawSolidStroke(n,m,b,y,w,R){this._hitTestStroke(n,b)}drawPictureStroke(n,m){this._hitTestStroke(n,m.width)}drawGradientStroke(n,m){this._hitTestStroke(n,m.width)}pushClipPath(n){}popClipPath(){}drawImage(n,m,b){const y=this._resourceManager.getResource(n);if((0,J.Wi)(y)||0===y.height||0===m)return;const w=m*this.geomUnitsPerPoint(),R=w*b*(y.width/y.height),D=this.reverseTransformPt(this._searchPoint),X=this._searchDistPoint;Math.abs(D[0])<R/2+X&&Math.abs(D[1])<w/2+X&&(this._earlyReturn=!0)}drawText(n){var m,b;const y=this._textInfo;if(!y)return;const w=y.get(n);if(!w)return;const{text:R,mosaicItem:D}=w;if(!D||0===D.glyphMosaicItems.length)return;const X=null!=(m=n.height)?m:10,tt=it(n.lineGapType,null!=(b=n.lineGap)?b:0,X),_t=(0,ct.E)(R)[1],ht=(0,Tt.Nr)(D.glyphMosaicItems,_t,{scale:X/Lt.Ex,angle:0,xOffset:0,yOffset:0,hAlign:K(n.horizontalAlignment),vAlign:et(n.verticalAlignment),maxLineWidth:512,lineHeight:Lt.xm*Math.max(.25,Math.min(tt||1,4)),decoration:n.font.decoration||"none",isCIM:!0}),kt=this.reverseTransformPt(this._searchPoint),T=kt[0],l=kt[1];for(const f of ht.glyphs)if(T>f.xTopLeft&&T<f.xBottomRight&&l>-f.yBottomRight&&l<-f.yTopLeft){this._earlyReturn=!0;break}}_hitTestFill(n){let m=null;if((0,I.YX)(n))m=[[[n.xmin,n.ymin],[n.xmin,n.ymax],[n.xmax,n.ymax],[n.xmax,n.ymin],[n.xmin,n.ymin]]];else if((0,I.oU)(n))m=n.rings;else{if(!(0,I.l9)(n))return;m=n.paths}const b=this.reverseTransformPt(this._searchPoint);this._pointInPolygon(b,m)&&(this._earlyReturn=!0);const y=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(b,m,y)&&(this._earlyReturn=!0)}_hitTestStroke(n,m){let b=null;if((0,I.YX)(n))b=[[[n.xmin,n.ymin],[n.xmin,n.ymax],[n.xmax,n.ymax],[n.xmax,n.ymin],[n.xmin,n.ymin]]];else if((0,I.oU)(n))b=n.rings;else{if(!(0,I.l9)(n))return;b=n.paths}const y=this.reverseTransformPt(this._searchPoint),w=m*this.geomUnitsPerPoint(),R=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(y,b,w/2+R)&&(this._earlyReturn=!0)}_pointInPolygon(n,m){let b=0;for(const y of m){const w=y.length;for(let R=1;R<w;++R){const D=y[R-1],X=y[R];D[1]>n[1]!=X[1]>n[1]&&((X[0]-D[0])*(n[1]-D[1])-(X[1]-D[1])*(n[0]-D[0])>0?b++:b--)}}return 0!==b}_nearLine(n,m,b){for(const y of m){const w=y.length;for(let R=1;R<w;++R){const D=y[R-1],X=y[R];let tt=(X[0]-D[0])*(X[0]-D[0])+(X[1]-D[1])*(X[1]-D[1]);if(0!==tt&&(tt=Math.sqrt(tt),Math.abs(((X[0]-D[0])*(n[1]-D[1])-(X[1]-D[1])*(n[0]-D[0]))/tt)<b)){const ut=((X[0]-D[0])*(n[0]-D[0])+(X[1]-D[1])*(n[1]-D[1]))/tt;if(ut>-b&&ut<tt+b)return!0}}}return!1}}class O extends N{constructor(n,m,b){super(m,b),this._ctx=n}drawSolidFill(n,m){if(!n)return;if((0,I.oU)(n))this._buildPath(n.rings,!0);else if((0,I.l9)(n))this._buildPath(n.paths,!0);else if((0,I.YX)(n))this._buildPath(G(n).rings,!0);else{if(!(0,I.aW)(n))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const b=this._ctx;b.fillStyle="string"==typeof m?m:"rgba("+Math.round(m[0])+","+Math.round(m[1])+","+Math.round(m[2])+","+m[3]/255+")",b.fill("evenodd")}drawSolidStroke(n,m,b,y,w,R){if(!n||!m||0===b)return;if((0,I.oU)(n))this._buildPath(n.rings,!0);else if((0,I.l9)(n))this._buildPath(n.paths,!1);else{if(!(0,I.YX)(n))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(G(n).rings,!0)}const D=this._ctx;D.strokeStyle="string"==typeof m?m:"rgba("+Math.round(m[0])+","+Math.round(m[1])+","+Math.round(m[2])+","+m[3]/255+")",D.lineWidth=this.transformSize(b)+.5,this._setCapStyle(y),this._setJoinStyle(w),D.miterLimit=R,D.stroke()}pushClipPath(n){if(this._ctx.save(),(0,I.oU)(n))this._buildPath(n.rings,!0);else if((0,I.l9)(n))this._buildPath(n.paths,!0);else{if(!(0,I.YX)(n))return;this._buildPath(G(n).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(n,m,b){const y=this._resourceManager.getResource(n);if((0,J.Wi)(y))return;const w=this._ctx,R=w.canvas.width,D=w.canvas.height;let X=m*b*(y.width/y.height),tt=b*m;m||(X=b*y.width,tt=b*y.height),this._ctx.drawImage(y,0,0,y.width,y.height,0,0,Math.min(this.transformSize(X),R),Math.min(this.transformSize(tt),D))}drawText(n){this._textRasterizer||(this._textRasterizer=new Et.d)}_buildPath(n,m){const b=this._ctx;if(b.beginPath(),n)for(const y of n){const w=y?y.length:0;if(w>1){let R=this.transformPt(y[0]);b.moveTo(R[0],R[1]);for(let D=1;D<w;++D)R=this.transformPt(y[D]),b.lineTo(R[0],R[1]);m&&b.closePath()}}}_setCapStyle(n){switch(n){case $.kP.Butt:this._ctx.lineCap="butt";break;case $.kP.Round:this._ctx.lineCap="round";break;case $.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(n){switch(n){case $.r4.Bevel:this._ctx.lineJoin="bevel";break;case $.r4.Round:this._ctx.lineJoin="round";break;case $.r4.Miter:this._ctx.lineJoin="miter"}}}const G=rt=>rt?{spatialReference:rt.spatialReference,rings:[[[rt.xmin,rt.ymin],[rt.xmin,rt.ymax],[rt.xmax,rt.ymax],[rt.xmax,rt.ymin],[rt.xmin,rt.ymin]]]}:null,K=rt=>{switch(rt){case"Left":return dt.M7.Left;case"Right":return dt.M7.Right;case"Center":case"Justify":return dt.M7.Center}},et=rt=>{switch(rt){case"Top":return dt.TR.Top;case"Center":return dt.TR.Center;case"Bottom":return dt.TR.Bottom;case"Baseline":return dt.TR.Baseline}},it=(rt,n,m)=>{switch(rt){case"ExtraLeading":return 1+n/m;case"Multiple":return n;case"Exact":return n/m}}},35909:(At,Pt,z)=>{z.d(Pt,{B$:()=>it,E0:()=>n,IV:()=>et,U1:()=>_t,fN:()=>rt,rW:()=>Q});var ct=z(91558),W=z(986),J=z(36161),lt=z(58817),xt=z(63290),M=z(21286),bt=z(62208),U=z(23841),I=z(65401),V=z(32442),j=z(97373),nt=z(89932),Z=z(7547),$=z(80991),pt=z(86575),Et=z(39351),dt=z(25797);const Lt=Math.PI,Tt=Lt/2,Ct=96/72,x=Math.PI/180,N=xt.Z.getLogger("esri.symbols.cim.CIMSymbolHelper");function Q(T){if(!T||!T.type)return null;let l;switch(T.type){case"cim":return T.data;case"web-style":return T;case"simple-marker":l=it.fromSimpleMarker(T);break;case"picture-marker":l=it.fromPictureMarker(T);break;case"simple-line":l=it.fromSimpleLineSymbol(T);break;case"simple-fill":l=it.fromSimpleFillSymbol(T);break;case"picture-fill":l=it.fromPictureFillSymbol(T);break;case"text":l=it.fromTextSymbol(T)}return{type:"CIMSymbolReference",symbol:l}}function k(T,l){switch(l.type){case"CIMSymbolReference":return k(T,l.symbol);case"CIMPointSymbol":case"CIMTextSymbol":T.drawSymbol(l,{x:0,y:0});break;case"CIMLineSymbol":T.drawSymbol(l,{paths:[[[0,0],[0,1]]]});break;case"CIMPolygonSymbol":T.drawSymbol(l,{rings:[[[0,0],[0,1],[0,0]]]});break;case"CIMVectorMarker":{const f=new j.u;T.drawMarker(l,f);break}}return T.envelope()}function O(T){if(!T)return 0;switch(T.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAtExtremities":case"CIMMarkerPlacementAtMeasuredUnits":case"CIMMarkerPlacementAtRatioPositions":case"CIMMarkerPlacementOnLine":case"CIMMarkerPlacementOnVertices":return Math.abs(T.offset);default:return 0}}function G(T){if(!T)return 0;switch(T.type){case"CIMGeometricEffectArrow":return Math.abs(.5*T.width);case"CIMGeometricEffectBuffer":return Math.abs(T.size);case"CIMGeometricEffectExtension":case"CIMGeometricEffectRadial":return Math.abs(T.length);case"CIMGeometricEffectJog":return Math.abs(.5*T.length);case"CIMGeometricEffectMove":return Math.max(Math.abs((0,$.NA)(T.offsetX)),Math.abs((0,$.NA)(T.offsetY)));case"CIMGeometricEffectOffset":case"CIMGeometricEffectOffsetTangent":return Math.abs(T.offset);case"CIMGeometricEffectRegularPolygon":return Math.abs(T.radius);case"CIMGeometricEffectRotate":case"CIMGeometricEffectScale":default:return 0;case"CIMGeometricEffectTaperedPolygon":return.5*Math.max(Math.abs(T.fromWidth),Math.abs(T.toWidth));case"CIMGeometricEffectWave":return Math.abs(T.amplitude)}}function K(T){if(!T)return 0;let l=0;for(const f of T)l+=G(f);return l}class et{getSymbolInflateSize(l,f,d,v,S){return l||(l=[0,0,0,0]),f?this._getInflateSize(l,f,d,v,S):l}static safeSize(l){const f=Math.max(Math.abs(l[0]),Math.abs(l[2])),d=Math.max(Math.abs(l[1]),Math.abs(l[3]));return Math.sqrt(f*f+d*d)}_vectorMarkerBounds(l,f,d,v){let S=!0;const P=(0,I.Ue)();if(f&&f.markerGraphics)for(const E of f.markerGraphics){const C=[0,0,0,0];E.geometry&&((0,V.$P)(P,E.geometry),C[0]=0,C[1]=0,C[2]=0,C[3]=0,this.getSymbolInflateSize(C,E.symbol,d,0,v),P[0]+=C[0],P[1]+=C[1],P[2]+=C[2],P[3]+=C[3],S?(l[0]=P[0],l[1]=P[1],l[2]=P[2],l[3]=P[3],S=!1):(l[0]=Math.min(l[0],P[0]),l[1]=Math.min(l[1],P[1]),l[2]=Math.max(l[2],P[2]),l[3]=Math.max(l[3],P[3])))}return l}_getInflateSize(l,f,d,v,S){if(function ut(T){return void 0!==T.symbolLayers}(f)){const P=this._getLayersInflateSize(l,f.symbolLayers,d,v,S),E=K(f.effects);return E>0&&(P[0]-=E,P[1]-=E,P[2]+=E,P[3]+=E),P}return this._getTextInflatedSize(l,f,S)}_getLayersInflateSize(l,f,d,v,S){let P=!0;if(!f)return l;for(const E of f){if(!E)continue;let C=[0,0,0,0];switch(E.type){case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const H=E;let st=H.width;st/=H.capStyle===Z.kP.Square||H.joinStyle===Z.r4.Miter?1.4142135623730951:2,C[0]=-st,C[1]=-st,C[2]=st,C[3]=st;break}case"CIMCharacterMarker":case"CIMVectorMarker":case"CIMPictureMarker":{const H=E;if("CIMVectorMarker"===E.type){const at=E;if(C=this._vectorMarkerBounds(C,at,d,S),at.frame){const mt=(at.frame.xmin+at.frame.xmax)/2,wt=(at.frame.ymin+at.frame.ymax)/2;C[0]-=mt,C[1]-=wt,C[2]-=mt,C[3]-=wt;const Mt=at.size/(at.frame.ymax-at.frame.ymin);C[0]*=Mt,C[1]*=Mt,C[2]*=Mt,C[3]*=Mt}}else if("CIMPictureMarker"===E.type){const at=E,mt=d.getResource(at.url);let wt=1;(0,bt.pC)(mt)&&mt.height&&(wt=mt.width/mt.height);const Mt=H.size/2,Dt=H.size*wt*at.scaleX/2;C=[-Dt,-Mt,Dt,Mt]}else{const at=H.size/2;C=[-at,-at,at,at]}if(H.anchorPoint){let at,mt;"Absolute"===H.anchorPointUnits?(at=H.anchorPoint.x,mt=H.anchorPoint.y):(at=H.anchorPoint.x*(C[2]-C[0]),mt=H.anchorPoint.y*(C[3]-C[1])),C[0]-=at,C[1]-=mt,C[2]-=at,C[3]-=mt}let st=(0,$.NA)(H.rotation);if(H.rotateClockwise&&(st=-st),v&&(st-=v),st){const at=x*st,mt=Math.cos(at),wt=Math.sin(at),Mt=(0,I.Ue)([pt.B1,pt.B1,-pt.B1,-pt.B1]);(0,I.Ho)(Mt,[C[0]*mt-C[1]*wt,C[0]*wt+C[1]*mt]),(0,I.Ho)(Mt,[C[0]*mt-C[3]*wt,C[0]*wt+C[3]*mt]),(0,I.Ho)(Mt,[C[2]*mt-C[1]*wt,C[2]*wt+C[1]*mt]),(0,I.Ho)(Mt,[C[2]*mt-C[3]*wt,C[2]*wt+C[3]*mt]),C=Mt}let gt=(0,$.NA)(H.offsetX),ot=(0,$.NA)(H.offsetY);if(v){const at=x*v,mt=Math.cos(at),wt=Math.sin(at),Mt=gt*wt+ot*mt;gt=gt*mt-ot*wt,ot=Mt}C[0]+=gt,C[1]+=ot,C[2]+=gt,C[3]+=ot;const ft=O(H.markerPlacement);ft>0&&(C[0]-=ft,C[1]-=ft,C[2]+=ft,C[3]+=ft);break}}const Y=K(E.effects);Y>0&&(C[0]-=Y,C[1]-=Y,C[2]+=Y,C[3]+=Y),P?(l[0]=C[0],l[1]=C[1],l[2]=C[2],l[3]=C[3],P=!1):(l[0]=Math.min(l[0],C[0]),l[1]=Math.min(l[1],C[1]),l[2]=Math.max(l[2],C[2]),l[3]=Math.max(l[3],C[3]))}return l}_getTextInflatedSize(l,f,d){var v,S;const P=null!=(v=f.height)?v:10;if(l[0]=-P/2,l[1]=-P/2,l[2]=P/2,l[3]=P/2,!d)return l;const E=d.get(f);if(!E)return l;const{text:C,mosaicItem:Y}=E;if(!Y||0===Y.glyphMosaicItems.length)return l;const H=(0,nt.et)(f.lineGapType,null!=(S=f.lineGap)?S:0,P),st=(0,W.E)(C)[1],ot=(0,dt.Nr)(Y.glyphMosaicItems,st,{scale:P/Et.Ex,angle:(0,$.NA)(f.angle),xOffset:(0,$.NA)(f.offsetX),yOffset:(0,$.NA)(f.offsetY),hAlign:(0,nt.x1)(f.horizontalAlignment),vAlign:(0,nt.g)(f.verticalAlignment),maxLineWidth:512,lineHeight:Et.xm*Math.max(.25,Math.min(H||1,4)),decoration:f.font.decoration||"none",isCIM:!0}).boundsT;return l[0]=ot.x-ot.halfWidth,l[1]=-ot.y-ot.halfHeight,l[2]=ot.x+ot.halfWidth,l[3]=-ot.y+ot.halfHeight,l}}class it{static getEnvelope(l,f){const d=new nt.uQ(f);if(Array.isArray(l)){let v;for(const S of l)v?v.union(k(d,S)):v=k(d,S);return v}return k(d,l)}static getTextureAnchor(l,f){const d=this.getEnvelope(l,f);if(!d)return[0,0,0];const E=d.height*Ct+2;return[(d.x+.5*d.width)*Ct/(d.width*Ct+2),-(d.y+.5*d.height)*Ct/E,E]}static rasterize(l,f,d,v,S=!0){const P=d||this.getEnvelope(f,v);if(!P)return[null,0,0,0,0];const E=(P.x+.5*P.width)*Ct,C=(P.y+.5*P.height)*Ct;l.width=P.width*Ct,l.height=P.height*Ct,d||(l.width+=2,l.height+=2);const Y=l.getContext("2d"),H=nt.zA.createScale(Ct,-Ct);H.translate(.5*l.width-E,.5*l.height+C);const st=new nt.cD(Y,v,H);switch(f.type){case"CIMPointSymbol":st.drawSymbol(f,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const ft=new j.u;st.drawMarker(f,ft);break}}const gt=Y.getImageData(0,0,l.width,l.height),ot=new Uint8Array(gt.data);if(S){let ft;for(let at=0;at<ot.length;at+=4)ft=ot[at+3]/255,ot[at]=ot[at]*ft,ot[at+1]=ot[at+1]*ft,ot[at+2]=ot[at+2]*ft}return[ot,l.width,l.height,-E/l.width,-C/l.height]}static fromTextSymbol(l){const{angle:f,color:d,font:v,haloColor:S,haloSize:P,horizontalAlignment:E,kerning:C,text:Y,verticalAlignment:H,xoffset:st,yoffset:gt}=l;let ot,ft,at,mt,wt;v&&(ot=v.family,ft=v.style,at=v.weight,mt=v.size,wt=v.decoration);let Mt=!1;return Y&&(Mt=(0,W.E)(Y)[1]),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:f,blockProgression:Z.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:Z.eZ.Normal,fontEncoding:Z.DD.Unicode,fontFamilyName:ot||"Arial",fontStyleName:D(ft,at),fontType:Z.Ky.Unspecified,haloSize:P,height:mt,hinting:Z.Dd.Default,horizontalAlignment:y(null!=E?E:"center"),kerning:C,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,$.NA)(st),offsetY:(0,$.NA)(gt),strikethrough:"line-through"===wt,underline:"underline"===wt,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:R(d)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:R(S)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:Mt?Z.UX.RTL:Z.UX.LTR,verticalAlignment:w(null!=H?H:"baseline"),verticalGlyphOrientation:Z.RS.Right,wordSpacing:100,billboardMode3D:Z.UR.FaceNearPlane},textString:Y}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(l){const{height:f,outline:d,width:v,xoffset:S,xscale:P,yoffset:E,yscale:C}=l,Y=[],H={type:"CIMPolygonSymbol",symbolLayers:Y};if(d){const{cap:at,join:mt,miterLimit:wt,width:Mt}=d;Y.push({type:"CIMSolidStroke",color:R(d.color),capStyle:m(at),joinStyle:b(mt),miterLimit:wt,width:Mt})}let st=l.url;"esriPFS"===l.type&&l.imageData&&(st=l.imageData);const gt="angle"in l?l.angle:0;return Y.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:Z.Qb.Picture,tintColor:null,url:st,height:f*(C||1),width:v*(P||1),offsetX:(0,$.NA)(S),offsetY:(0,$.NA)(E),rotation:(0,$.NA)(-gt),colorSubstitutions:null}),H}static fromSimpleFillSymbol(l){const{color:f,style:d,outline:v}=l,S=[],P={type:"CIMPolygonSymbol",symbolLayers:S};let E=null;if(v){const{cap:C,join:Y,style:H}=v;"solid"!==H&&"none"!==H&&"esriSLSSolid"!==H&&"esriSLSNull"!==H&&(E=[{type:"CIMGeometricEffectDashes",dashTemplate:_t(H,C),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),S.push({type:"CIMSolidStroke",color:R(v.color),capStyle:m(C),joinStyle:b(Y),miterLimit:v.miterLimit,width:v.width,effects:E})}if(d&&"solid"!==d&&"none"!==d&&"esriSFSSolid"!==d&&"esriSFSNull"!==d){const C={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:R(f),capStyle:Z.kP.Butt,joinStyle:Z.r4.Miter,width:.75}]};let Y=0;const H=(0,M.fp)(Math.ceil(window.devicePixelRatio)),st=kt(d)?8*H:10*H;switch(d){case"vertical":case"esriSFSVertical":Y=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":Y=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":Y=45;break;case"cross":case"esriSFSCross":Y=0}S.push({type:"CIMHatchFill",lineSymbol:C,offsetX:0,offsetY:0,rotation:Y,separation:st}),"cross"===d||"esriSFSCross"===d?S.push({type:"CIMHatchFill",lineSymbol:(0,lt.d9)(C),offsetX:0,offsetY:0,rotation:90,separation:st}):"diagonal-cross"!==d&&"esriSFSDiagonalCross"!==d||S.push({type:"CIMHatchFill",lineSymbol:(0,lt.d9)(C),offsetX:0,offsetY:0,rotation:45,separation:st})}else!d||"solid"!==d&&"esriSFSSolid"!==d||S.push({type:"CIMSolidFill",enable:!0,color:R(f)});return P}static fromSimpleLineSymbol(l){const{cap:f,color:d,join:v,marker:S,miterLimit:P,style:E,width:C}=l;let Y=null;"solid"!==E&&"none"!==E&&"esriSLSSolid"!==E&&"esriSLSNull"!==E&&(Y=[{type:"CIMGeometricEffectDashes",dashTemplate:_t(E,f),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const H=[];if(S){let st;switch(S.placement){case"begin-end":st=Z.Tx.Both;break;case"begin":st=Z.Tx.JustBegin;break;case"end":st=Z.Tx.JustEnd;break;default:st=Z.Tx.None}const gt=it.fromSimpleMarker(S,C,d).symbolLayers[0];gt.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:st,offsetAlongLine:0},H.push(gt)}return"none"!==E&&"esriSLSNull"!==E&&H.push({type:"CIMSolidStroke",color:R(d),capStyle:m(f),joinStyle:b(v),miterLimit:P,width:C,effects:Y}),{type:"CIMLineSymbol",symbolLayers:H}}static fromPictureMarker(l){const{angle:f,height:d,width:v,xoffset:S,yoffset:P}=l;let E=l.url;return"esriPMS"===l.type&&l.imageData&&(E=l.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:Z.Qb.Picture,tintColor:null,url:E,size:d,width:v,offsetX:(0,$.NA)(S),offsetY:(0,$.NA)(P),rotation:(0,$.NA)(-f)}]}}static fromSimpleMarker(l,f,d){var v;const{style:S}=l,P=null!=(v=l.color)?v:d;if("path"===S){const H=[];if("outline"in l&&l.outline){const ot=l.outline;H.push({type:"CIMSolidStroke",enable:!0,width:(0,U.F2)(Math.round((0,U.Wz)(ot.width))),color:R(ot.color)})}H.push({type:"CIMSolidFill",enable:!0,color:R(P),path:l.path});const[st,gt]=ht("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,$.NA)(-l.angle),size:(0,$.NA)(l.size||6),offsetX:(0,$.NA)(l.xoffset),offsetY:(0,$.NA)(l.yoffset),frame:st,markerGraphics:[{type:"CIMMarkerGraphic",geometry:gt,symbol:{type:"CIMPolygonSymbol",symbolLayers:H}}]}]}}const[E,C]=ht(S);let Y;if(C&&E){const H=[];if("outline"in l&&l.outline){const gt=l.outline;H.push({type:"CIMSolidStroke",enable:!0,width:gt.width>.667?(0,U.F2)(Math.round((0,U.Wz)(gt.width))):gt.width,color:R(gt.color)})}else!f||"line-marker"!==l.type||"cross"!==l.style&&"x"!==l.style||H.push({type:"CIMSolidStroke",enable:!0,width:f,color:R(P)});H.push({type:"CIMSolidFill",enable:!0,color:R(P)});const st={type:"CIMPolygonSymbol",symbolLayers:H};Y={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,$.NA)(-l.angle),size:(0,$.NA)(l.size||6*f),offsetX:(0,$.NA)(l.xoffset),offsetY:(0,$.NA)(l.yoffset),frame:E,markerGraphics:[{type:"CIMMarkerGraphic",geometry:C,symbol:st}]}]}}return Y}static fromCIMHatchFill(l){var f;const d=null!=(f=l.separation)?f:4,v=d/2;let P=this._getLineSymbolPeriod(l.lineSymbol)||4;for(;P<4;)P*=2;const E=P/2;return{type:"CIMVectorMarker",frame:{xmin:-E,xmax:E,ymin:-v,ymax:v},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-E,0],[E,0]]]},symbol:l.lineSymbol}],size:d}}static _getLineSymbolPeriod(l){if(l){const f=this._getEffectsRepeat(l.effects);if(f)return f;if(l.symbolLayers)for(const d of l.symbolLayers){const v=this._getEffectsRepeat(d.effects);if(v)return v;if(d){const S=this._getPlacementRepeat(d.markerPlacement);if(S)return S}}}return 0}static _getEffectsRepeat(l){if(l)for(const f of l)if(f)switch(f.type){case"CIMGeometricEffectDashes":{const d=f.dashTemplate;if(d&&d.length){let v=0;for(const S of d)v+=S;return 1&d.length&&(v*=2),v}break}case"CIMGeometricEffectWave":return f.period;default:N.error(`unsupported geometric effect type ${f.type}`)}return 0}static _getPlacementRepeat(l){if(l)switch(l.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const f=l.placementTemplate;if(f&&f.length){let d=0;for(const v of f)d+=v;return 1&f.length&&(d*=2),d}break}}return 0}static fromCIMInsidePolygon(l){const f=l.markerPlacement,d=Ut({type:l.type},l);let v,S,P,E;return d.markerPlacement=null,d.anchorPoint=null,!0===f.shiftOddRows?(S=f.stepX/2,P=f.stepY,E=2*f.stepY,v=[{x:-S,y:0},{x:S,y:0},{x:0,y:P},{x:0,y:-P}].map(C=>({type:"CIMMarkerGraphic",geometry:C,symbol:{type:"CIMPointSymbol",symbolLayers:[d]}}))):(S=f.stepX/2,P=f.stepY/2,E=f.stepY,v=[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMPointSymbol",symbolLayers:[d]}}]),{type:"CIMVectorMarker",frame:{xmin:-S,xmax:S,ymin:-P,ymax:P},markerGraphics:v,size:E}}static getFillColor(l){if(!l)return null;switch(l.type){case"CIMPolygonSymbol":if(l.symbolLayers)for(const f of l.symbolLayers){const d=it.getFillColor(f);if(null!=d)return d}break;case"CIMTextSymbol":return it.getFillColor(l.symbol);case"CIMSolidFill":return l.color}}static getStrokeColor(l){if(l)switch(l.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(l.symbolLayers)for(const f of l.symbolLayers){const d=it.getStrokeColor(f);if(void 0!==d)return d}break;case"CIMTextSymbol":return it.getStrokeColor(l.symbol);case"CIMSolidStroke":return l.color}}static getStrokeWidth(l){if(l)switch(l.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(l.symbolLayers)for(const f of l.symbolLayers){const d=it.getStrokeWidth(f);if(void 0!==d)return d}break;case"CIMTextSymbol":return it.getStrokeWidth(l.symbol);case"CIMSolidStroke":case"CIMGradientStroke":case"CIMPictureStroke":return l.width}}static getSize(l){if(l)switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{let f=0;if(l.symbolLayers)for(const d of l.symbolLayers){const v=it.getSize(d);v>f&&(f=v)}return f}case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":return l.width;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":return l.size}}static getMarkerScaleRatio(l){return l&&"CIMVectorMarker"===l.type&&!1!==l.scaleSymbolsProportionally&&l.frame?l.size/(l.frame.ymax-l.frame.ymin):1}}class rt{static rasterizeSimpleFill(l,f,d){"solid"!==f&&"none"!==f&&"esriSFSSolid"!==f&&"esriSFSNull"!==f||console.error("Unexpected: style does not require rasterization");const v=(0,M.fp)(Math.ceil(d)),S=kt(f)?8*v:16*v,P=2*v;l.width=S,l.height=S;const E=l.getContext("2d");E.strokeStyle="#FFFFFF",E.lineWidth=v,E.beginPath(),"vertical"!==f&&"cross"!==f&&"esriSFSCross"!==f&&"esriSFSVertical"!==f||(E.moveTo(S/2,-P),E.lineTo(S/2,S+P)),"horizontal"!==f&&"cross"!==f&&"esriSFSCross"!==f&&"esriSFSHorizontal"!==f||(E.moveTo(-P,S/2),E.lineTo(S+P,S/2)),"forward-diagonal"!==f&&"diagonal-cross"!==f&&"esriSFSDiagonalCross"!==f&&"esriSFSForwardDiagonal"!==f||(E.moveTo(-P,-P),E.lineTo(S+P,S+P),E.moveTo(S-P,-P),E.lineTo(S+P,P),E.moveTo(-P,S-P),E.lineTo(P,S+P)),"backward-diagonal"!==f&&"diagonal-cross"!==f&&"esriSFSBackwardDiagonal"!==f&&"esriSFSDiagonalCross"!==f||(E.moveTo(S+P,-P),E.lineTo(-P,S+P),E.moveTo(P,-P),E.lineTo(-P,P),E.moveTo(S+P,S-P),E.lineTo(S-P,S+P)),E.stroke();const C=E.getImageData(0,0,l.width,l.height),Y=new Uint8Array(C.data);let H;for(let st=0;st<Y.length;st+=4)H=Y[st+3]/255,Y[st]=Y[st]*H,Y[st+1]=Y[st+1]*H,Y[st+2]=Y[st+2]*H;return[Y,l.width,l.height]}static rasterizeSimpleLine(l,f){return this.rasterizeDash(l,f)}static rasterizeDash(l,f){const d="Butt"===f,v="Square"===f,S=!d&&!v;l.length%2==1&&(l=[...l,...l]);const P=15.5;let C=0;for(const Mt of l)C+=Mt;const Y=Math.round(C*P),H=new Float32Array(31*Y);let gt=0,ot=0,ft=.5,at=!0;for(const Mt of l){for(gt=ot,ot+=Mt*P;ft<=ot;){let Dt=.5;for(;Dt<31;){const Ft=(Dt-.5)*Y+ft-.5,Ot=S?(Dt-P)*(Dt-P):Math.abs(Dt-P);H[Ft]=at?d?Math.max(Math.max(gt+7.75-ft,Ot),Math.max(ft-ot+7.75,Ot)):Ot:S?Math.min((ft-gt)*(ft-gt)+Ot,(ft-ot)*(ft-ot)+Ot):v?Math.min(Math.max(ft-gt,Ot),Math.max(ot-ft,Ot)):Math.min(Math.max(ft-gt+7.75,Ot),Math.max(ot+7.75-ft,Ot)),Dt++}ft++}at=!at}const mt=H.length,wt=new Uint8Array(4*mt);for(let Mt=0;Mt<mt;++Mt){const Dt=(S?Math.sqrt(H[Mt]):H[Mt])/P;(0,J.I)(Dt,wt,4*Mt)}return[wt,Y,31]}}class n{static findApplicableOverrides(l,f,d){if(l&&f){if(l.primitiveName){let v=!1;for(const S of d)if(S.primitiveName===l.primitiveName){v=!0;break}if(!v)for(const S of f)S.primitiveName===l.primitiveName&&d.push(S)}switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(l.effects)for(const v of l.effects)n.findApplicableOverrides(v,f,d);if(l.symbolLayers)for(const v of l.symbolLayers)n.findApplicableOverrides(v,f,d);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(l.effects)for(const v of l.effects)n.findApplicableOverrides(v,f,d);if(l.markerPlacement&&n.findApplicableOverrides(l.markerPlacement,f,d),"CIMVectorMarker"===l.type){if(l.markerGraphics)for(const v of l.markerGraphics)n.findApplicableOverrides(v,f,d),n.findApplicableOverrides(v.symbol,f,d)}else"CIMCharacterMarker"===l.type?n.findApplicableOverrides(l.symbol,f,d):"CIMHatchFill"===l.type&&n.findApplicableOverrides(l.lineSymbol,f,d)}}}static findEffectOverrides(l,f,d){if(!f||!l)return;const v=l.length;for(let S=0;S<v;S++){const P=l[S],E=null==P?void 0:P.primitiveName;if(E){let C=!1;for(const Y of d)if(Y.primitiveName===E){C=!0;break}if(!C)for(const Y of f)Y.primitiveName===E&&d.push(Y)}}}static applyOverrides(l,f,d,v){if(!f)return;const S=P=>P&&P.charAt(0).toLowerCase()+P.substr(1);if(l.primitiveName)for(const P of f)if(P.primitiveName===l.primitiveName){const E=S(P.propertyName);if(v&&v.push({cim:l,nocapPropertyName:E,value:l[E]}),P.expression&&(P.value=n.toValue(P.propertyName,P.expression)),d){let C=!1;for(const Y of d)Y.primitiveName===l.primitiveName&&(C=!0);C||d.push(P)}l[E]=P.value}switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(l.effects)for(const P of l.effects)n.applyOverrides(P,f,d,v);if(l.symbolLayers)for(const P of l.symbolLayers)n.applyOverrides(P,f,d,v);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(l.effects)for(const P of l.effects)n.applyOverrides(P,f,d,v);if("CIMVectorMarker"===l.type&&l.markerGraphics)for(const P of l.markerGraphics)n.applyOverrides(P,f,d,v),n.applyOverrides(P.symbol,f,d,v)}}static restoreOverrides(l){for(const f of l)f.cim[f.nocapPropertyName]=f.value}static buildOverrideKey(l){let f="";for(const d of l)void 0!==d.value&&(f+=`${d.primitiveName}${d.propertyName}${JSON.stringify(d.value)}`);return f}static toValue(l,f){if("DashTemplate"===l)return f.split(" ").map(d=>Number(d));if("Color"===l){const d=new ct.Z(f).toRgba();return d[3]*=255,d}return f}}const m=T=>{if(!T)return Z.kP.Butt;switch(T){case"butt":return Z.kP.Butt;case"square":return Z.kP.Square;case"round":return Z.kP.Round}},b=T=>{if(!T)return Z.r4.Miter;switch(T){case"miter":return Z.r4.Miter;case"round":return Z.r4.Round;case"bevel":return Z.r4.Bevel}},y=T=>{if(!T)return"Center";switch(T){case"left":return"Left";case"right":return"Right";case"center":return"Center";case"justify":return"Justify"}},w=T=>{if(!T)return"Center";switch(T){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},R=T=>{if(!T)return[0,0,0,0];const{r:l,g:f,b:d,a:v}=T;return[l,f,d,255*v]},D=(T,l)=>{const f=X(l),d=tt(T);return f&&d?`${f}-${d}`:`${f}${d}`},X=T=>{if(!T)return"";switch(T.toLowerCase()){case"bold":case"bolder":return"bold"}return""},tt=T=>{if(!T)return"";switch(T.toLowerCase()){case"italic":case"oblique":return"italic"}return""},_t=(T,l)=>{const f="butt"===l;switch(T){case"dash":case"esriSLSDash":return f?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return f?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return f?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return f?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return f?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return f?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return f?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return f?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return f?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return f?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return N.error("Unexpected: style does not require rasterization"),[0,0];default:return N.error(`Tried to rasterize SLS, but found an unexpected style: ${T}!`),[0,0]}},ht=T=>{let d,v;const S=T;if("circle"===S||"esriSMSCircle"===S){let E=Math.acos(.995),C=Math.ceil(Lt/E/4);0===C&&(C=1),E=Tt/C,C*=4;const Y=[];Y.push([50,0]);for(let H=1;H<C;H++)Y.push([50*Math.cos(H*E),-50*Math.sin(H*E)]);Y.push([50,0]),d={rings:[Y]},v={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===S||"esriSMSCross"===S)d={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},v={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===S||"esriSMSDiamond"===S)d={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},v={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===S||"esriSMSSquare"===S)d={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},v={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===S||"esriSMSX"===S)d={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},v={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===S||"esriSMSTriangle"===S){const P=57.735026918962575,E=-P,C=2/3*100,Y=C-100;d={rings:[[[E,Y],[0,C],[P,Y],[E,Y]]]},v={xmin:E,ymin:Y,xmax:P,ymax:C}}else"arrow"===S&&(d={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},v={xmin:-50,ymin:-50,xmax:50,ymax:50});return[v,d]},kt=T=>"vertical"===T||"horizontal"===T||"cross"===T||"esriSFSCross"===T||"esriSFSVertical"===T||"esriSFSHorizontal"===T},31375:(At,Pt,z)=>{z.d(Pt,{Z:()=>ct});class ct{constructor(J=0,lt=0,xt=0,M=0){this.x=J,this.y=lt,this.width=xt,this.height=M}get isEmpty(){return this.width<=0||this.height<=0}union(J){this.x=Math.min(this.x,J.x),this.y=Math.min(this.y,J.y),this.width=Math.max(this.width,J.width),this.height=Math.max(this.height,J.height)}}},68937:(At,Pt,z)=>{z.d(Pt,{d:()=>lt});var ct=z(23841);class lt{constructor(){}rasterizeText(U,I){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const V=this._textRasterizationCanvas,j=V.getContext("2d");this._setFontProperties(j,I),this.parameters=I,this.textLines=U.split(/\r?\n/),this.lineHeight=this._computeLineHeight();const nt=this._computeTextWidth(j,I),{decoration:Z,weight:$}=I.font;this.lineThroughWidthOffset=Z&&"line-through"===Z?.1*this.lineHeight:0;const pt=this.lineHeight*this.textLines.length;V.width=nt+2*this.lineThroughWidthOffset,V.height=pt,this.renderedLineHeight=Math.round(this.lineHeight*I.pixelRatio),this.renderedHaloSize=I.halo.size*I.pixelRatio,this.renderedWidth=nt*I.pixelRatio,this.renderedHeight=pt*I.pixelRatio,this.lineThroughWidthOffset*=I.pixelRatio,this.fillStyle=function J(bt){return`rgba(${bt.slice(0,3).toString()},${bt[3]})`}(I.color),this.haloStyle=function W(bt){return`rgb(${bt.slice(0,3).toString()})`}(I.halo.color);const Et=this.renderedLineHeight,dt=this.renderedHaloSize;this._setFontProperties(j,I);const Lt=function xt(bt,U){return"center"===bt?.5*U:"right"===bt?U:0}(j.textAlign,this.renderedWidth)+dt,Tt=dt;let zt=this.lineThroughWidthOffset,Ct=0;dt>0&&this._renderHalo(j,Lt,Tt,zt,Ct,I),Ct+=Tt,zt+=Lt;for(const O of this.textLines)j.globalCompositeOperation="destination-out",j.fillStyle="rgb(0, 0, 0)",j.fillText(O,zt,Ct),j.globalCompositeOperation="source-over",j.fillStyle=this.fillStyle,j.fillText(O,zt,Ct),Z&&"none"!==Z&&this._renderDecoration(j,zt,Ct,Z,$),Ct+=Et;const x=this.renderedWidth+2*this.lineThroughWidthOffset,N=this.renderedHeight,Q=j.getImageData(0,0,x,N),k=new Uint8Array(Q.data);if(I.premultiplyColors){let O;for(let G=0;G<k.length;G+=4)O=k[G+3]/255,k[G]=k[G]*O,k[G+1]=k[G+1]*O,k[G+2]=k[G+2]*O}return{size:[x,N],image:new Uint32Array(k.buffer),sdf:!1,simplePattern:!1,anchorX:0,anchorY:0}}_renderHalo(U,I,V,j,nt,Z){const $=this.renderedWidth,pt=this.renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=$,this._haloRasterizationCanvas.height=pt;const Et=this._haloRasterizationCanvas,dt=Et.getContext("2d");dt.clearRect(0,0,$,pt),this._setFontProperties(dt,Z);const{decoration:Lt,weight:Tt}=Z.font;dt.fillStyle=this.haloStyle,dt.strokeStyle=this.haloStyle;const It=this.renderedHaloSize<3;dt.lineJoin=It?"miter":"round",It?this._renderHaloEmulated(dt,I,V,Lt,Tt):this._renderHaloNative(dt,I,V,Lt,Tt),U.globalAlpha=this.parameters.halo.color[3],U.drawImage(Et,0,0,$,pt,j,nt,$,pt),U.globalAlpha=1}_renderHaloEmulated(U,I,V,j,nt){const Z=this.renderedLineHeight,$=this.renderedHaloSize;for(const pt of this.textLines){for(const[Et,dt]of M)U.fillText(pt,I+$*Et,V+$*dt);j&&"none"!==j&&this._renderDecoration(U,I,V,j,nt),V+=Z}}_renderHaloNative(U,I,V,j,nt){const Z=this.renderedLineHeight,$=this.renderedHaloSize;for(const pt of this.textLines){const Et=2*$,dt=5,Lt=.1;for(let Tt=0;Tt<dt;Tt++)U.lineWidth=(1-(dt-1)*Lt+Tt*Lt)*Et,U.strokeText(pt,I,V),j&&"none"!==j&&this._renderDecoration(U,I,V,j,nt);V+=Z}}_setFontProperties(U,I){const V=I.font,j=`${V.style} ${V.weight} ${(0,ct.F2)(I.size*I.pixelRatio)}px ${V.family}, sans-serif`;let nt;switch(U.font=j,U.textBaseline="top",I.horizontalAlignment){case"left":default:nt="left";break;case"right":nt="right";break;case"center":nt="center"}U.textAlign=nt}computeTextSize(U,I){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const V=this._textRasterizationCanvas,j=V.getContext("2d");this._setFontProperties(j,I),this.parameters=I,this.textLines=U.split(/\r?\n/),this.lineHeight=this._computeLineHeight();const nt=this._computeTextWidth(j,I),Z=this.lineHeight*this.textLines.length;return V.width=nt,V.height=Z,[nt*I.pixelRatio,Z*I.pixelRatio]}_computeTextWidth(U,I){let V=0;for(const nt of this.textLines)V=Math.max(V,U.measureText(nt).width);const j=I.font;return("italic"===j.style||"oblique"===j.style||"string"==typeof j.weight&&("bold"===j.weight||"bolder"===j.weight)||"number"==typeof j.weight&&j.weight>600)&&(V+=.3*U.measureText("w").width),V+=2*this.parameters.halo.size,Math.round(V)}_computeLineHeight(){let U=1.275*this.parameters.size;const I=this.parameters.font.decoration;return I&&"underline"===I&&(U*=1.3),Math.round(U+2*this.parameters.halo.size)}_renderDecoration(U,I,V,j,nt){const Z=.9*this.lineHeight,$="bold"===nt?.06:"bolder"===nt?.09:.04;switch(U.textAlign){case"center":I-=this.renderedWidth/2;break;case"right":I-=this.renderedWidth}const pt=U.textBaseline;if("underline"===j)switch(pt){case"top":V+=Z;break;case"middle":V+=Z/2}else if("line-through"===j)switch(pt){case"top":V+=Z/1.5;break;case"middle":V+=Z/3}U.save(),U.beginPath(),U.strokeStyle=U.fillStyle,U.lineWidth=Math.ceil(Z*$),U.moveTo(I-this.lineThroughWidthOffset,V),U.lineTo(I+this.renderedWidth+2*this.lineThroughWidthOffset,V),U.stroke(),U.restore()}}const M=[];for(let U=0;U<360;U+=22.5)M.push([Math.cos(Math.PI*U/180),Math.sin(Math.PI*U/180)])},25797:(At,Pt,z)=>{z.d(Pt,{Nr:()=>N});var ct=z(31478),W=z(12225),J=z(67831),lt=z(9545),xt=z(61261),M=z(5254),bt=z(84439);class U{constructor(k,O,G,K){this.center=(0,lt.f)(k,O),this.centerT=(0,lt.c)(),this.halfWidth=G/2,this.halfHeight=K/2,this.width=G,this.height=K}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(k){this.center[0]=k}set y(k){this.center[1]=k}clone(){return new U(this.x,this.y,this.width,this.height)}serialize(k){return k.writeF32(this.center[0]),k.writeF32(this.center[1]),k.push(this.width),k.push(this.height),k}findCollisionDelta(k,O=4){const G=Math.abs(k.centerT[0]-this.centerT[0]),K=Math.abs(k.centerT[1]-this.centerT[1]),rt=Math.min((k.halfWidth+this.halfWidth+O)/G,(k.halfHeight+this.halfHeight+O)/K);return Math.log2(rt)}extend(k){const O=Math.min(this.xmin,k.xmin),G=Math.min(this.ymin,k.ymin),K=Math.max(this.xmax,k.xmax)-O,et=Math.max(this.ymax,k.ymax)-G,it=O+K/2,rt=G+et/2;this.width=K,this.height=et,this.halfWidth=K/2,this.halfHeight=et/2,this.x=it,this.y=rt}static deserialize(k){const O=k.readF32(),G=k.readF32(),K=k.readInt32(),et=k.readInt32();return new U(O,G,K,et)}}const pt=Math.PI/180;class Et{constructor(k,O,G,K){this._rotationT=(0,W.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const et=G.rect,it=new Float32Array(8);O*=K;const rt=G.code?et.width*K:G.metrics.width,n=G.code?et.height*K:G.metrics.height;it[0]=k*=K,it[1]=O,it[2]=k+rt,it[3]=O,it[4]=k,it[5]=O+n,it[6]=k+rt,it[7]=O+n,this._data=it,this._setTextureCoords(et),this._scale=K,this._mosaic=G,this.x=k,this.y=O,this.maxOffset=Math.max(k+rt,O+n)}get width(){return this._mosaic.metrics.width*this._scale}get mosaic(){return this._mosaic}set angle(k){this._angle=k,(0,ct.b)(this._rotationT,-k),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:k,width:O}=this._mosaic.metrics,G=O*this._scale,K=Math.abs(k)*this._scale,et=new Float32Array(8);et[0]=this.x,et[1]=this.y,et[2]=this.x+G,et[3]=this.y,et[4]=this.x,et[5]=this.y+K,et[6]=this.x+G,et[7]=this.y+K;const it=(0,ct.m)((0,W.c)(),this._rotationT,this._T);(0,W.t)(et,et,it);let rt=1/0,n=1/0,m=0,b=0;for(let X=0;X<4;X++){const tt=et[2*X],_t=et[2*X+1];rt=Math.min(rt,tt),n=Math.min(n,_t),m=Math.max(m,tt),b=Math.max(b,_t)}const y=m-rt,w=b-n;this._bounds=new U(rt+y/2,n+w/2,y,w)}return this._bounds}setTransform(k){this._T=k,this._offsets=null}_setOffsets(k){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const O=this._offsets,G=new Float32Array(8),K=(0,ct.m)((0,W.c)(),this._rotationT,this._T);(0,W.t)(G,k,K),O.upperLeft=(0,M.UJ)(8*G[0],8*G[1]),O.upperRight=(0,M.UJ)(8*G[2],8*G[3]),O.lowerLeft=(0,M.UJ)(8*G[4],8*G[5]),O.lowerRight=(0,M.UJ)(8*G[6],8*G[7])}_setTextureCoords({x:k,y:O,width:G,height:K}){this._texcoords={upperLeft:(0,M.UJ)(k,O),upperRight:(0,M.UJ)(k+G,O),lowerLeft:(0,M.UJ)(k,O+K),lowerRight:(0,M.UJ)(k+G,O+K)}}}const dt=(Q,k)=>({code:0,page:0,sdf:!0,rect:new bt.Z(0,0,11,8),textureBinding:k,metrics:{advance:0,height:4,width:Q,left:0,top:0}});class Lt{constructor(k,O,G){this._rotation=0,this._decorate(k,O,G),this.glyphs=k,this.bounds=this._createBounds(k),this.isMultiline=O.length>1,this._hasRotation=0!==G.angle,this._T=this._createGlyphTransform(this.bounds,G);for(const K of k)K.setTransform(this._T)}setRotation(k){if(0===k&&0===this._rotation)return;this._rotation=k;const O=this._T,G=(0,ct.b)((0,W.c)(),k);(0,ct.m)(O,G,O);for(const K of this.glyphs)K.setTransform(this._T)}_decorate(k,O,G){if(!G.decoration||"none"===G.decoration||!k.length)return;const K=G.scale,et="underline"===G.decoration?30:20,it=k[0].textureBinding;for(const rt of O)k.push(new Et(rt.startX*K,rt.startY*K+et*K,dt((rt.width+rt.glyphWidthEnd)*K,it),1))}get boundsT(){const k=this.bounds,O=(0,J.s)((0,lt.c)(),k.x,k.y);if((0,J.t)(O,O,this._T),this._hasRotation){const G=Math.max(k.width,k.height);return new U(O[0],O[1],G,G)}return new U(O[0],O[1],k.width,k.height)}_createBounds(k){let O=1/0,G=1/0,K=0,et=0;for(const n of k)O=Math.min(O,n.xTopLeft),G=Math.min(G,n.yTopLeft),K=Math.max(K,n.xTopLeft+n.width),et=Math.max(et,n.yBottomRight);const it=K-O,rt=et-G;return new U(O+it/2,G+rt/2,it,rt)}_createGlyphTransform(k,O){const G=pt*O.angle,K=(0,W.c)(),et=(0,lt.c)();return(0,ct.t)(K,K,(0,J.s)(et,O.xOffset,-O.yOffset)),O.isCIM?(0,ct.r)(K,K,G):((0,ct.t)(K,K,(0,J.s)(et,k.x,k.y)),(0,ct.r)(K,K,G),(0,ct.t)(K,K,(0,J.s)(et,-k.x,-k.y))),K}}class Tt{constructor(k,O,G,K,et,it){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(O,G)),this.end=Math.max(0,Math.max(O,G)),this.end<k.length&&(this.glyphWidthEnd=k[this.end].metrics.width),this.width=K,this.yMin=et,this.yMax=it}}const It=Q=>10===Q,zt=Q=>32===Q;function N(Q,k,O){const G=O.scale,K=new Array,et=function Ct(Q,k,O){const G=new Array,et=O.maxLineWidth*(1/O.scale),it=k?Q.length-1:0,rt=k?-1:Q.length,n=k?-1:1;let m=it,b=0,y=0,w=m,R=w,D=0,X=1/0,tt=0;for(;m!==rt;){const{code:ut,metrics:ht}=Q[m],kt=Math.abs(ht.top);It(ut)||zt(ut)||(X=Math.min(X,kt),tt=Math.max(tt,kt+ht.height)),It(ut)?(m!==it&&(G.push(new Tt(Q,w,m-n,b,X,tt)),X=1/0,tt=0),b=0,w=m+n,R=m+n,y=0):zt(ut)?(R=m+n,y=0,D=ht.advance,b+=ht.advance):b>et?(R!==w?(b-=D,G.push(new Tt(Q,w,R-2*n,b-y,X,tt)),X=1/0,tt=0,w=R,b=y):(G.push(new Tt(Q,w,m-n,b,X,tt)),X=1/0,tt=0,w=m,R=m,b=0),b+=ht.advance,y+=ht.advance):(b+=ht.advance,y+=ht.advance),m+=n}const _t=new Tt(Q,w,m-n,b,X,tt);return _t.start>=0&&_t.end<Q.length&&G.push(_t),G}(Q,k,O),it=function x(Q,k){let O=0;for(let et=0;et<Q.length;et++){const{width:it}=Q[et];O=Math.max(it,O)}const K=Q[0].yMin;return{x:0,y:K,height:Q[Q.length-1].yMax+k.lineHeight*(Q.length-1)+("underline"===k.decoration?4:0)-K,width:O}}(et,O),{vAlign:rt,hAlign:n}=O,m=rt===xt.TR.Baseline?1:0,y=(1-m)*-it.y+it.height/2*(m?0:rt-1)+-26*(m?1:0);for(let w=0;w<et.length;w++){const{start:R,end:D,width:X}=et[w];let tt=-1*(n+1)*(X/2)-3;const _t=w*O.lineHeight+y-3;et[w].startX=tt,et[w].startY=_t;for(let ut=R;ut<=D;ut++){const ht=Q[ut];if(It(ht.code))continue;const kt=new Et(tt+ht.metrics.left,_t-ht.metrics.top,ht,G);tt+=ht.metrics.advance,K.push(kt)}}return new Lt(K,et,O)}}}]);